(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pencilTracer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
(function() {
  var CoffeeScriptInstrumenter, InstrumentError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  InstrumentError = (function(superClass) {
    extend(InstrumentError, superClass);

    function InstrumentError(message) {
      this.message = message;
      this.name = "InstrumentError";
      Error.call(this);
      Error.captureStackTrace(this, arguments.callee);
    }

    return InstrumentError;

  })(Error);

  CoffeeScriptInstrumenter = (function() {
    function CoffeeScriptInstrumenter(coffee1) {
      this.coffee = coffee1;
      if (this.coffee == null) {
        throw "Error: a CoffeeScript compiler must be passed to CoffeeScriptInstrumenter!";
      }
      this.getNodeTypes();
    }

    CoffeeScriptInstrumenter.prototype.getNodeTypes = function() {
      var icedNodes;
      this.nodeTypes = {
        'Block': this.coffee.nodes("").constructor,
        'Literal': this.coffee.nodes("0").expressions[0].base.constructor,
        'Undefined': this.coffee.nodes("undefined").expressions[0].base.constructor,
        'Null': this.coffee.nodes("null").expressions[0].base.constructor,
        'Bool': this.coffee.nodes("true").expressions[0].base.constructor,
        'Return': this.coffee.nodes("return").expressions[0].constructor,
        'Value': this.coffee.nodes("0").expressions[0].constructor,
        'Comment': this.coffee.nodes("###\n###").expressions[0].constructor,
        'Call': this.coffee.nodes("f()").expressions[0].constructor,
        'Extends': this.coffee.nodes("A extends B").expressions[0].constructor,
        'Access': this.coffee.nodes("a.b").expressions[0].properties[0].constructor,
        'Index': this.coffee.nodes("a[0]").expressions[0].properties[0].constructor,
        'Range': this.coffee.nodes("[0..1]").expressions[0].base.constructor,
        'Slice': this.coffee.nodes("a[0..1]").expressions[0].properties[0].constructor,
        'Obj': this.coffee.nodes("{}").expressions[0].base.constructor,
        'Arr': this.coffee.nodes("[]").expressions[0].base.constructor,
        'Class': this.coffee.nodes("class").expressions[0].constructor,
        'Assign': this.coffee.nodes("a=0").expressions[0].constructor,
        'Code': this.coffee.nodes("->").expressions[0].constructor,
        'Param': this.coffee.nodes("(a)->").expressions[0].params[0].constructor,
        'Splat': this.coffee.nodes("[a...]").expressions[0].base.objects[0].constructor,
        'Expansion': this.coffee.nodes("[...]").expressions[0].base.objects[0].constructor,
        'While': this.coffee.nodes("0 while true").expressions[0].constructor,
        'Op': this.coffee.nodes("1+1").expressions[0].constructor,
        'In': this.coffee.nodes("0 in []").expressions[0].constructor,
        'Try': this.coffee.nodes("try").expressions[0].constructor,
        'Throw': this.coffee.nodes("throw 0").expressions[0].constructor,
        'Existence': this.coffee.nodes("a?").expressions[0].constructor,
        'Parens': this.coffee.nodes("(0)").expressions[0].base.constructor,
        'For': this.coffee.nodes("0 for a in []").expressions[0].constructor,
        'Switch': this.coffee.nodes("switch a\n  when 0 then 0").expressions[0].constructor,
        'If': this.coffee.nodes("0 if 0").expressions[0].constructor
      };
      if (this.coffee.iced != null) {
        icedNodes = this.coffee.nodes("await f defer a");
        this.nodeTypes.IcedRuntime = icedNodes.expressions[0].constructor;
        this.nodeTypes.Await = icedNodes.expressions[1].constructor;
        this.nodeTypes.Defer = icedNodes.expressions[1].body.expressions[0].args[0].constructor;
        return this.nodeTypes.Slot = icedNodes.expressions[1].body.expressions[0].args[0].slots[0].constructor;
      } else {
        return this.nodeTypes.IcedRuntime = this.nodeTypes.Await = this.nodeTypes.Defer = this.nodeTypes.Slot = function() {};
      }
    };

    CoffeeScriptInstrumenter.prototype.makeUndefinedNode = function() {
      return this.coffee.nodes("undefined").expressions[0];
    };

    CoffeeScriptInstrumenter.prototype.makeAssignNode = function(variableName, valueNode) {
      var node;
      node = this.coffee.nodes("x = 0").expressions[0];
      node.variable.base.value = variableName;
      node.value = valueNode;
      return node;
    };

    CoffeeScriptInstrumenter.prototype.makeReturnNode = function(variableName) {
      var node;
      node = this.coffee.nodes("return x").expressions[0];
      node.expression.base.value = variableName;
      return node;
    };

    CoffeeScriptInstrumenter.prototype.fixLocationData = function(instrumentedNode, lineNum) {
      var doIt;
      doIt = function(node) {
        return node.locationData = {
          first_line: lineNum,
          first_column: 0,
          last_line: lineNum,
          last_column: 0
        };
      };
      doIt(instrumentedNode);
      return instrumentedNode.eachChild(doIt);
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(traceFunc, locationData, eventType) {
      var instrumentedNode, locationObj;
      locationObj = "{ first_line: " + (locationData.first_line + 1) + ",";
      locationObj += " first_column: " + (locationData.first_column + 1) + ",";
      locationObj += " last_line: " + (locationData.last_line + 1) + ",";
      locationObj += " last_column: " + (locationData.last_column + 1) + " }";
      instrumentedNode = this.coffee.nodes(traceFunc + "({ location: " + locationObj + ", type: '" + eventType + "' })");
      this.fixLocationData(instrumentedNode, locationData.first_line);
      return instrumentedNode;
    };

    CoffeeScriptInstrumenter.prototype.temporaryVariable = function(name, used) {
      var curName, index;
      index = 0;
      while (true) {
        curName = "" + name + index;
        if (indexOf.call(used, curName) < 0) {
          return curName;
        }
        index++;
      }
    };

    CoffeeScriptInstrumenter.prototype.instrument = function(filename, code, options) {
      var ast, err, instrumentTree, js, ref, referencedVars, token, tokens, traceFunc;
      if (options == null) {
        options = {};
      }
      traceFunc = (ref = options.traceFunc) != null ? ref : "pencilTrace";
      try {
        tokens = this.coffee.tokens(code, {});
        referencedVars = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token.variable) {
              results.push(token[1]);
            }
          }
          return results;
        })();
        ast = this.coffee.nodes(tokens);
      } catch (_error) {
        err = _error;
        throw new InstrumentError("Could not parse " + filename + ": " + err.stack);
      }
      instrumentTree = (function(_this) {
        return function(node, nodeIndex, parent, inCode) {
          var assignNode, childIndex, children, expression, instrumentedNode, lastExpr, tempVariableName;
          if (nodeIndex == null) {
            nodeIndex = null;
          }
          if (parent == null) {
            parent = null;
          }
          if (inCode == null) {
            inCode = null;
          }
          if (node instanceof _this.nodeTypes.Code) {
            inCode = node;
          }
          if (node instanceof _this.nodeTypes.Block && !(parent instanceof _this.nodeTypes.Parens)) {
            children = node.expressions;
            childIndex = 0;
            while (childIndex < children.length) {
              expression = children[childIndex];
              if (!(expression.doNotInstrument || expression instanceof _this.nodeTypes.Comment || expression instanceof _this.nodeTypes.IcedRuntime)) {
                instrumentedNode = _this.createInstrumentedNode(traceFunc, expression.locationData, "");
                children.splice(childIndex, 0, instrumentedNode);
                childIndex++;
                instrumentTree(expression, childIndex, node, inCode);
              }
              childIndex++;
            }
            if (parent instanceof _this.nodeTypes.Code) {
              children.splice(0, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "enter"));
              if (children.length === 1) {
                children.splice(1, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "leave"));
                return children.splice(2, 0, _this.makeUndefinedNode());
              } else {
                lastExpr = children[children.length - 1];
                if (!(lastExpr instanceof _this.nodeTypes.Return || lastExpr instanceof _this.nodeTypes.Await)) {
                  tempVariableName = _this.temporaryVariable("_tempReturnVal", referencedVars);
                  referencedVars.push(tempVariableName);
                  assignNode = _this.makeAssignNode(tempVariableName, lastExpr);
                  children.splice(children.length - 1, 1, assignNode);
                  children.splice(children.length, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "leave"));
                  return children.splice(children.length, 0, _this.coffee.nodes(tempVariableName).expressions[0]);
                }
              }
            }
          } else {
            if (node instanceof _this.nodeTypes.Return && (inCode != null)) {
              if (!(parent instanceof _this.nodeTypes.Block)) {
                throw new InstrumentError("Encountered a Return whose parent is not a Block. This is a bug, please report!");
              }
              tempVariableName = _this.temporaryVariable("_tempReturnVal", referencedVars);
              referencedVars.push(tempVariableName);
              assignNode = _this.makeAssignNode(tempVariableName, node.expression);
              parent.expressions.splice(nodeIndex, 1, assignNode);
              parent.expressions.splice(nodeIndex + 1, 0, _this.createInstrumentedNode(traceFunc, inCode.locationData, "leave"));
              parent.expressions.splice(nodeIndex + 2, 0, _this.makeReturnNode(tempVariableName));
              parent.expressions[nodeIndex].doNotInstrument = true;
              parent.expressions[nodeIndex + 1].doNotInstrument = true;
              parent.expressions[nodeIndex + 2].doNotInstrument = true;
            }
            return node.eachChild(function(child) {
              return instrumentTree(child, null, node, inCode);
            });
          }
        };
      })(this);
      instrumentTree(ast);
      if (options.ast) {
        return ast;
      }
      try {
        js = ast.compile({
          runtime: "inline"
        });
      } catch (_error) {
        err = _error;
        throw new InstrumentError("Could not compile " + filename + " after instrumenting: " + err.stack);
      }
      return js;
    };

    return CoffeeScriptInstrumenter;

  })();

  exports.instrumentCoffee = function(filename, code, coffee, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new CoffeeScriptInstrumenter(coffee);
    return instrumenter.instrument(filename, code, options);
  };

}).call(this);

},{}]},{},[1])(1)
});