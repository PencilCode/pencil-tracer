// Generated by CoffeeScript 1.9.3
(function() {
  var CoffeeScriptInstrumenter,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CoffeeScriptInstrumenter = (function() {
    function CoffeeScriptInstrumenter(coffee1, options1) {
      var base1;
      this.coffee = coffee1;
      this.options = options1 != null ? options1 : {};
      if (this.coffee == null) {
        throw new Error("A CoffeeScript compiler must be passed to CoffeeScriptInstrumenter!");
      }
      if ((base1 = this.options).traceFunc == null) {
        base1.traceFunc = "pencilTrace";
      }
      this.getNodeTypes();
    }

    CoffeeScriptInstrumenter.prototype.getNodeTypes = function() {
      var awaitNode, icedNodes;
      this.nodeTypes = {
        'Block': this.coffee.nodes("").constructor,
        'Literal': this.coffee.nodes("0").expressions[0].base.constructor,
        'Undefined': this.coffee.nodes("undefined").expressions[0].base.constructor,
        'Null': this.coffee.nodes("null").expressions[0].base.constructor,
        'Bool': this.coffee.nodes("true").expressions[0].base.constructor,
        'Return': this.coffee.nodes("return").expressions[0].constructor,
        'Value': this.coffee.nodes("0").expressions[0].constructor,
        'Comment': this.coffee.nodes("###\n###").expressions[0].constructor,
        'Call': this.coffee.nodes("f()").expressions[0].constructor,
        'Extends': this.coffee.nodes("A extends B").expressions[0].constructor,
        'Access': this.coffee.nodes("a.b").expressions[0].properties[0].constructor,
        'Index': this.coffee.nodes("a[0]").expressions[0].properties[0].constructor,
        'Range': this.coffee.nodes("[0..1]").expressions[0].base.constructor,
        'Slice': this.coffee.nodes("a[0..1]").expressions[0].properties[0].constructor,
        'Obj': this.coffee.nodes("{}").expressions[0].base.constructor,
        'Arr': this.coffee.nodes("[]").expressions[0].base.constructor,
        'Class': this.coffee.nodes("class").expressions[0].constructor,
        'Assign': this.coffee.nodes("a=0").expressions[0].constructor,
        'Code': this.coffee.nodes("->").expressions[0].constructor,
        'Param': this.coffee.nodes("(a)->").expressions[0].params[0].constructor,
        'Splat': this.coffee.nodes("[a...]").expressions[0].base.objects[0].constructor,
        'Expansion': this.coffee.nodes("[...]").expressions[0].base.objects[0].constructor,
        'While': this.coffee.nodes("0 while true").expressions[0].constructor,
        'Op': this.coffee.nodes("1+1").expressions[0].constructor,
        'In': this.coffee.nodes("0 in []").expressions[0].constructor,
        'Try': this.coffee.nodes("try").expressions[0].constructor,
        'Throw': this.coffee.nodes("throw 0").expressions[0].constructor,
        'Existence': this.coffee.nodes("a?").expressions[0].constructor,
        'Parens': this.coffee.nodes("(0)").expressions[0].base.constructor,
        'For': this.coffee.nodes("0 for a in []").expressions[0].constructor,
        'Switch': this.coffee.nodes("switch a\n  when 0 then 0").expressions[0].constructor,
        'If': this.coffee.nodes("0 if 0").expressions[0].constructor
      };
      if (this.coffee.iced != null) {
        icedNodes = this.coffee.nodes("if 1\n  await f defer a\n  1");
        awaitNode = icedNodes.expressions[1].body.expressions[0];
        this.nodeTypes.IcedRuntime = icedNodes.expressions[0].constructor;
        this.nodeTypes.Await = awaitNode.constructor;
        this.nodeTypes.Defer = awaitNode.body.expressions[0].args[0].constructor;
        this.nodeTypes.Slot = awaitNode.body.expressions[0].args[0].slots[0].constructor;
        return this.nodeTypes.IcedTailCall = awaitNode.icedContinuationBlock.expressions[0].constructor;
      } else {
        return this.nodeTypes.IcedRuntime = this.nodeTypes.Await = this.nodeTypes.Defer = this.nodeTypes.Slot = this.nodeTypes.IcedTailCall = function() {};
      }
    };

    CoffeeScriptInstrumenter.prototype.temporaryVariable = function(base) {
      var curName, index, name;
      name = "_penciltracer_" + base;
      index = 0;
      while (true) {
        curName = name + index;
        if (indexOf.call(this.referencedVars, curName) < 0) {
          this.referencedVars.push(curName);
          return curName;
        }
        index++;
      }
    };

    CoffeeScriptInstrumenter.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;
      while (i--) {
        if (!(list[i] instanceof this.nodeTypes.Comment)) {
          return list[i];
        }
      }
      return null;
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(eventType, options) {
      var eventObj, extra, instrumentedNode, location, locationObj, name, ref, ref1, vars;
      if (options == null) {
        options = {};
      }
      if (options.node instanceof this.nodeTypes.IcedTailCall) {
        options.node = options.node.value;
      }
      location = (ref = options.location) != null ? ref : options.node.locationData;
      if (eventType !== "leave") {
        vars = (ref1 = options.vars) != null ? ref1 : (eventType === "enter" ? this.findArguments(options.node) : this.findVariables(options.node));
      }
      locationObj = "{ first_line: " + (location.first_line + 1) + ",";
      locationObj += " first_column: " + (location.first_column + 1) + ",";
      locationObj += " last_line: " + (location.last_line + 1) + ",";
      locationObj += " last_column: " + (location.last_column + 1) + " }";
      extra = (function() {
        switch (eventType) {
          case "before":
          case "after":
            return "vars: {" + ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = vars.length; j < len; j++) {
                name = vars[j];
                results.push("'" + name + "': (if typeof " + name + " is 'undefined' then undefined else " + name + ")");
              }
              return results;
            })()) + "}";
          case "enter":
            return "vars: {" + ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = vars.length; j < len; j++) {
                name = vars[j];
                results.push("'" + name + "': " + name);
              }
              return results;
            })()) + "}";
          case "leave":
            return "returnOrThrow: " + options.returnOrThrowVar;
        }
      })();
      eventObj = "{ location: " + locationObj + ", type: '" + eventType + "', " + extra + " }";
      instrumentedNode = this.coffee.nodes(this.options.traceFunc + "(" + eventObj + ")").expressions[0];
      instrumentedNode.pencilTracerInstrumented = true;
      return instrumentedNode;
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedExpr = function(originalExpr) {
      var assignNode, parensBlock, tempVar;
      tempVar = this.temporaryVariable("temp");
      assignNode = this.coffee.nodes(tempVar + " = 0").expressions[0];
      assignNode.value = originalExpr;
      parensBlock = this.coffee.nodes("(0)").expressions[0];
      parensBlock.base.body.expressions = [];
      parensBlock.base.body.expressions[0] = this.createInstrumentedNode("before", {
        node: originalExpr
      });
      parensBlock.base.body.expressions[1] = assignNode;
      parensBlock.base.body.expressions[2] = this.createInstrumentedNode("after", {
        node: originalExpr
      });
      parensBlock.base.body.expressions[3] = this.coffee.nodes(tempVar).expressions[0];
      return parensBlock;
    };

    CoffeeScriptInstrumenter.prototype.findVariables = function(node, parent, vars) {
      var j, lastProp, len, name, prop, ref, skip;
      if (parent == null) {
        parent = null;
      }
      if (vars == null) {
        vars = [];
      }
      if (!node) {
        return [];
      }
      if (node.pencilTracerInstrumented) {
        return [];
      }
      if (node instanceof this.nodeTypes.Defer) {
        return [];
      }
      if (node instanceof this.nodeTypes.Value && node.base instanceof this.nodeTypes.Literal && node.base.isAssignable()) {
        skip = parent instanceof this.nodeTypes.Assign && parent.context === "object" && parent.variable === node;
        skip || (skip = parent instanceof this.nodeTypes.Call && parent.variable === node && node.properties.length === 0);
        if (!skip) {
          name = node["this"] ? "@" : node.base.value + ".";
          lastProp = node.properties[node.properties.length - 1];
          ref = node.properties;
          for (j = 0, len = ref.length; j < len; j++) {
            prop = ref[j];
            if (!(prop instanceof this.nodeTypes.Access) || prop.soak || (prop === lastProp && parent instanceof this.nodeTypes.Call && parent.variable === node)) {
              break;
            }
            name += prop.name.value + ".";
          }
          if (name !== "@") {
            name = name.slice(0, -1);
          }
          if (vars.indexOf(name) === -1) {
            vars.push(name);
          }
        }
      }
      node.eachChild((function(_this) {
        return function(child) {
          skip = child instanceof _this.nodeTypes.Block && !(node instanceof _this.nodeTypes.Parens);
          skip || (skip = child instanceof _this.nodeTypes.Code);
          skip || (skip = !_this.shouldInstrumentNode(child));
          if (!skip) {
            return _this.findVariables(child, node, vars);
          }
        };
      })(this));
      return vars;
    };

    CoffeeScriptInstrumenter.prototype.findArguments = function(codeNode) {
      var args, j, len, name, paramNode, ref;
      if (!(codeNode instanceof this.nodeTypes.Code)) {
        throw new Error("findArguments() expects a Code node");
      }
      args = [];
      ref = codeNode.params;
      for (j = 0, len = ref.length; j < len; j++) {
        paramNode = ref[j];
        name = paramNode.name;
        if (name instanceof this.nodeTypes.Literal) {
          args.push(name.value);
        } else if (name instanceof this.nodeTypes.Value) {
          args.push("@" + name.properties[0].name.value);
        } else {
          args.push.apply(args, this.findVariables(name));
        }
      }
      return args;
    };

    CoffeeScriptInstrumenter.prototype.nodeIsObj = function(node) {
      return node instanceof this.nodeTypes.Value && node.isObject(true);
    };

    CoffeeScriptInstrumenter.prototype.nodeIsClassProperty = function(node, className) {
      return this.nodeIsObj(node) || (node instanceof this.nodeTypes.Assign && node.variable.looksStatic(className)) || (node instanceof this.nodeTypes.Assign && node.variable["this"]);
    };

    CoffeeScriptInstrumenter.prototype.shouldSkipNode = function(node) {
      return node.pencilTracerInstrumented || node instanceof this.nodeTypes.IcedRuntime;
    };

    CoffeeScriptInstrumenter.prototype.shouldInstrumentNode = function(node) {
      return !node.pencilTracerInstrumented && !(node instanceof this.nodeTypes.IcedRuntime) && (!(node instanceof this.nodeTypes.IcedTailCall) || node.value) && !(node instanceof this.nodeTypes.Comment) && !(node instanceof this.nodeTypes.For) && !(node instanceof this.nodeTypes.While) && !(node instanceof this.nodeTypes.Switch) && !(node instanceof this.nodeTypes.If) && !(node instanceof this.nodeTypes.Class) && !(node instanceof this.nodeTypes.Try) && !(node instanceof this.nodeTypes.Await);
    };

    CoffeeScriptInstrumenter.prototype.compileAst = function(ast, originalCode, compileOptions) {
      var SourceMap, answer, compilerName, currentColumn, currentLine, fragment, fragments, header, j, js, len, map, newLines;
      SourceMap = this.coffee.compile("", {
        sourceMap: true
      }).sourceMap.constructor;
      if (compileOptions.sourceMap) {
        map = new SourceMap;
      }
      fragments = ast.compileToFragments(compileOptions);
      currentLine = 0;
      if (compileOptions.header) {
        currentLine += 1;
      }
      if (compileOptions.shiftLine) {
        currentLine += 1;
      }
      currentColumn = 0;
      js = "";
      for (j = 0, len = fragments.length; j < len; j++) {
        fragment = fragments[j];
        if (compileOptions.sourceMap) {
          if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
            map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
              noReplace: true
            });
          }
          newLines = this.coffee.helpers.count(fragment.code, "\n");
          currentLine += newLines;
          if (newLines) {
            currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
          } else {
            currentColumn += fragment.code.length;
          }
        }
        js += fragment.code;
      }
      if (compileOptions.header) {
        compilerName = this.coffee.iced != null ? "IcedCoffeeScript" : "CoffeeScript";
        header = "Generated by " + compilerName + " " + this.coffee.VERSION + " (instrumented by pencil-tracer)";
        js = "// " + header + "\n" + js;
      }
      if (compileOptions.sourceMap) {
        answer = {
          js: js
        };
        answer.sourceMap = map;
        answer.v3SourceMap = map.generate(compileOptions, originalCode);
        return answer;
      } else {
        return js;
      }
    };

    CoffeeScriptInstrumenter.prototype.instrumentTree = function(node, parent, inClass, returnOrThrowVar) {
      var after, afterNode, assignNode, before, beforeNode, block, caseClause, childIndex, children, expression, i, j, k, lastChild, len, len1, location, objValue, parensBlock, prop, ref, ref1, ref2, results, temp, tryNode, vars;
      if (parent == null) {
        parent = null;
      }
      if (inClass == null) {
        inClass = false;
      }
      if (this.shouldSkipNode(node)) {
        return;
      }
      if (node instanceof this.nodeTypes.Class) {
        inClass = node;
      }
      if (this.nodeIsObj(node)) {
        inClass = false;
      }
      if (node instanceof this.nodeTypes.Block && !(parent instanceof this.nodeTypes.Parens)) {
        children = node.expressions;
        lastChild = this.lastNonComment(children);
        childIndex = 0;
        if (!returnOrThrowVar) {
          returnOrThrowVar = this.temporaryVariable("returnOrThrow");
          children.unshift(this.coffee.nodes(returnOrThrowVar + " = {}").expressions[0]);
          childIndex = 1;
        }
        results = [];
        while (childIndex < children.length) {
          expression = children[childIndex];
          if (inClass && this.nodeIsObj(expression) && expression.base.properties.length > 1) {
            children.splice(childIndex, 1);
            ref = expression.base.properties;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              prop = ref[i];
              objValue = this.coffee.nodes("{}").expressions[0];
              objValue.locationData = objValue.base.locationData = prop.locationData;
              objValue.base.properties = objValue.base.objects = [prop];
              objValue.base.generated = expression.base.generated;
              children.splice(childIndex + i, 0, objValue);
            }
            expression = children[childIndex];
          }
          if (this.shouldInstrumentNode(expression)) {
            beforeNode = this.createInstrumentedNode("before", {
              node: expression
            });
            afterNode = this.createInstrumentedNode("after", {
              node: expression
            });
            children.splice(childIndex, 0, beforeNode);
            childIndex++;
            children.splice(childIndex + 1, 0, afterNode);
            childIndex++;
            if (expression instanceof this.nodeTypes.Return) {
              assignNode = this.coffee.nodes(returnOrThrowVar + ".value = 0").expressions[0];
              assignNode.value = expression.expression || this.coffee.nodes("undefined").expressions[0];
              children[childIndex - 1] = assignNode;
              children.splice(childIndex + 1, 0, this.coffee.nodes("return " + returnOrThrowVar + ".value").expressions[0]);
              childIndex++;
            } else if (expression instanceof this.nodeTypes.Throw) {
              assignNode = this.coffee.nodes(returnOrThrowVar + ".value = 0").expressions[0];
              assignNode.value = expression.expression;
              children[childIndex - 1] = assignNode;
              children.splice(childIndex + 1, 0, this.coffee.nodes("throw " + returnOrThrowVar + ".value").expressions[0]);
              childIndex++;
            } else if (expression instanceof this.nodeTypes.Literal && ((ref1 = expression.value) === "break" || ref1 === "continue")) {
              temp = children[childIndex];
              children[childIndex] = children[childIndex - 1];
              children[childIndex - 1] = temp;
            } else if (expression === lastChild && !expression.jumps() && !(expression instanceof this.nodeTypes.Await) && !(inClass && this.nodeIsClassProperty(expression, inClass.determineName())) && !(parent instanceof this.nodeTypes.Try && parent.ensure === node)) {
              assignNode = this.coffee.nodes(returnOrThrowVar + ".value = 0").expressions[0];
              assignNode.value = expression;
              children[childIndex - 1] = assignNode;
              children.splice(childIndex + 1, 0, this.coffee.nodes(returnOrThrowVar + ".value").expressions[0]);
              children[childIndex + 1].icedHasAutocbFlag = expression.icedHasAutocbFlag;
              childIndex++;
            }
          }
          this.instrumentTree(expression, node, inClass, returnOrThrowVar);
          results.push(childIndex++);
        }
        return results;
      } else if (node instanceof this.nodeTypes.For) {
        if (!node.range) {
          node.source = this.createInstrumentedExpr(node.source);
        }
        if (node.guard) {
          node.guard = this.createInstrumentedExpr(node.guard);
        }
        if (node.name && node.index) {
          if (node.object) {
            location = {
              first_line: node.name.locationData.first_line,
              first_column: node.name.locationData.first_column,
              last_line: node.index.locationData.last_line,
              last_column: node.index.locationData.last_column
            };
          } else {
            location = {
              first_line: node.index.locationData.first_line,
              first_column: node.index.locationData.first_column,
              last_line: node.name.locationData.last_line,
              last_column: node.name.locationData.last_column
            };
          }
          vars = [node.name.value, node.index.value];
        } else if (node.name) {
          location = node.name.locationData;
          vars = [node.name.value];
        } else if (node.index) {
          location = node.index.locationData;
          vars = [node.index.value];
        } else {
          location = node.locationData;
          vars = [];
        }
        before = this.createInstrumentedNode("before", {
          location: location,
          vars: vars
        });
        after = this.createInstrumentedNode("after", {
          location: location,
          vars: vars
        });
        if (node.guard) {
          parensBlock = this.coffee.nodes("(0)").expressions[0];
          parensBlock.base.body.expressions = [before, after, node.guard];
          node.guard = parensBlock;
        } else {
          node.body.expressions.unshift(before, after);
        }
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.While) {
        node.condition = this.createInstrumentedExpr(node.condition);
        if (node.guard) {
          node.guard = this.createInstrumentedExpr(node.guard);
        }
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Switch) {
        if (node.subject) {
          node.subject = this.createInstrumentedExpr(node.subject);
        }
        ref2 = node.cases;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          caseClause = ref2[k];
          if (caseClause[0] instanceof Array) {
            caseClause[0][0] = this.createInstrumentedExpr(caseClause[0][0]);
          } else {
            caseClause[0] = this.createInstrumentedExpr(caseClause[0]);
          }
        }
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.If) {
        node.condition = this.createInstrumentedExpr(node.condition);
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Class) {
        before = this.createInstrumentedNode("before", {
          node: node
        });
        after = this.createInstrumentedNode("after", {
          node: node
        });
        node.body.expressions.unshift(before, after);
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Try) {
        if (node.recovery && node.errorVariable) {
          before = this.createInstrumentedNode("before", {
            node: node.errorVariable,
            vars: [node.errorVariable.value]
          });
          after = this.createInstrumentedNode("after", {
            node: node.errorVariable,
            vars: [node.errorVariable.value]
          });
          node.recovery.expressions.unshift(before, after);
        }
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Code) {
        returnOrThrowVar = this.temporaryVariable("returnOrThrow");
        block = this.coffee.nodes(returnOrThrowVar + " = { type: 'return', value: undefined }\ntry\ncatch " + this.caughtErrorVar + "\n  " + returnOrThrowVar + ".type = 'throw'\n  " + returnOrThrowVar + ".value = " + this.caughtErrorVar + "\n  throw " + this.caughtErrorVar + "\nfinally");
        tryNode = block.expressions[1];
        tryNode.attempt = node.body;
        block.expressions.unshift(this.createInstrumentedNode("enter", {
          node: node
        }));
        tryNode.ensure.expressions.unshift(this.createInstrumentedNode("leave", {
          node: node,
          returnOrThrowVar: returnOrThrowVar
        }));
        node.body = block;
        return this.instrumentTree(tryNode.attempt, tryNode, inClass, returnOrThrowVar);
      } else {
        node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
        if (node.icedContinuationBlock != null) {
          return this.instrumentTree(node.icedContinuationBlock, node, inClass, returnOrThrowVar);
        }
      }
    };

    CoffeeScriptInstrumenter.prototype.instrument = function(filename, code) {
      var ast, csOptions, result, token;
      csOptions = {
        runtime: "inline",
        bare: this.options.bare,
        header: this.options.header,
        sourceMap: this.options.sourceMap,
        literate: this.options.literate
      };
      this.referencedVars = csOptions.referencedVars = (function() {
        var j, len, ref, results;
        ref = this.coffee.tokens(code, csOptions);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          token = ref[j];
          if (token.variable) {
            results.push(token[1]);
          }
        }
        return results;
      }).call(this);
      this.caughtErrorVar = this.temporaryVariable("err");
      ast = this.coffee.nodes(code, csOptions);
      this.instrumentTree(ast);
      if (this.options.ast) {
        return ast;
      }
      result = this.compileAst(ast, code, csOptions);
      return result;
    };

    return CoffeeScriptInstrumenter;

  })();

  exports.instrumentCoffee = function(filename, code, coffee, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new CoffeeScriptInstrumenter(coffee, options);
    return instrumenter.instrument(filename, code);
  };

}).call(this);
