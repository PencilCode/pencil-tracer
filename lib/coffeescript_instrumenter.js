// Generated by CoffeeScript 1.9.3
(function() {
  var CoffeeScriptInstrumenter, Scope;

  Scope = require("./scope").Scope;

  CoffeeScriptInstrumenter = (function() {
    function CoffeeScriptInstrumenter(coffee1, options1) {
      var base;
      this.coffee = coffee1;
      this.options = options1 != null ? options1 : {};
      if (this.coffee == null) {
        throw new Error("A CoffeeScript compiler must be passed to CoffeeScriptInstrumenter!");
      }
      if ((base = this.options).traceFunc == null) {
        base.traceFunc = "pencilTrace";
      }
      this.getNodeTypes();
    }

    CoffeeScriptInstrumenter.prototype.getNodeTypes = function() {
      var icedNodes;
      this.nodeTypes = {
        'Block': this.coffee.nodes("").constructor,
        'Literal': this.coffee.nodes("0").expressions[0].base.constructor,
        'Undefined': this.coffee.nodes("undefined").expressions[0].base.constructor,
        'Null': this.coffee.nodes("null").expressions[0].base.constructor,
        'Bool': this.coffee.nodes("true").expressions[0].base.constructor,
        'Return': this.coffee.nodes("return").expressions[0].constructor,
        'Value': this.coffee.nodes("0").expressions[0].constructor,
        'Comment': this.coffee.nodes("###\n###").expressions[0].constructor,
        'Call': this.coffee.nodes("f()").expressions[0].constructor,
        'Extends': this.coffee.nodes("A extends B").expressions[0].constructor,
        'Access': this.coffee.nodes("a.b").expressions[0].properties[0].constructor,
        'Index': this.coffee.nodes("a[0]").expressions[0].properties[0].constructor,
        'Range': this.coffee.nodes("[0..1]").expressions[0].base.constructor,
        'Slice': this.coffee.nodes("a[0..1]").expressions[0].properties[0].constructor,
        'Obj': this.coffee.nodes("{}").expressions[0].base.constructor,
        'Arr': this.coffee.nodes("[]").expressions[0].base.constructor,
        'Class': this.coffee.nodes("class").expressions[0].constructor,
        'Assign': this.coffee.nodes("a=0").expressions[0].constructor,
        'Code': this.coffee.nodes("->").expressions[0].constructor,
        'Param': this.coffee.nodes("(a)->").expressions[0].params[0].constructor,
        'Splat': this.coffee.nodes("[a...]").expressions[0].base.objects[0].constructor,
        'Expansion': this.coffee.nodes("[...]").expressions[0].base.objects[0].constructor,
        'While': this.coffee.nodes("0 while true").expressions[0].constructor,
        'Op': this.coffee.nodes("1+1").expressions[0].constructor,
        'In': this.coffee.nodes("0 in []").expressions[0].constructor,
        'Try': this.coffee.nodes("try").expressions[0].constructor,
        'Throw': this.coffee.nodes("throw 0").expressions[0].constructor,
        'Existence': this.coffee.nodes("a?").expressions[0].constructor,
        'Parens': this.coffee.nodes("(0)").expressions[0].base.constructor,
        'For': this.coffee.nodes("0 for a in []").expressions[0].constructor,
        'Switch': this.coffee.nodes("switch a\n  when 0 then 0").expressions[0].constructor,
        'If': this.coffee.nodes("0 if 0").expressions[0].constructor
      };
      if (this.coffee.iced != null) {
        icedNodes = this.coffee.nodes("await f defer a");
        this.nodeTypes.IcedRuntime = icedNodes.expressions[0].constructor;
        this.nodeTypes.Await = icedNodes.expressions[1].constructor;
        this.nodeTypes.Defer = icedNodes.expressions[1].body.expressions[0].args[0].constructor;
        return this.nodeTypes.Slot = icedNodes.expressions[1].body.expressions[0].args[0].slots[0].constructor;
      } else {
        return this.nodeTypes.IcedRuntime = this.nodeTypes.Await = this.nodeTypes.Defer = this.nodeTypes.Slot = function() {};
      }
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(targetNode, eventType) {
      var eventObj, instrumentedNode, locationData, locationObj, varsObj;
      locationData = targetNode.locationData;
      locationObj = "{ first_line: " + (locationData.first_line + 1) + ",";
      locationObj += " first_column: " + (locationData.first_column + 1) + ",";
      locationObj += " last_line: " + (locationData.last_line + 1) + ",";
      locationObj += " last_column: " + (locationData.last_column + 1) + " }";
      varsObj = targetNode.pencilTracerScope.toCode();
      eventObj = "{ location: " + locationObj + ", type: '" + eventType + "', vars: " + varsObj + " }";
      instrumentedNode = this.coffee.nodes(this.options.traceFunc + "(" + eventObj + ")").expressions[0];
      instrumentedNode.pencilTracerInstrumented = true;
      return instrumentedNode;
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedExpr = function(targetNode, eventType, originalExpr) {
      var parensBlock;
      parensBlock = this.coffee.nodes("(0)").expressions[0];
      parensBlock.base.body.expressions = [];
      parensBlock.base.body.expressions[0] = this.createInstrumentedNode(targetNode, "code");
      parensBlock.base.body.expressions[1] = originalExpr;
      return parensBlock;
    };

    CoffeeScriptInstrumenter.prototype.shouldSkipNode = function(node) {
      return node.pencilTracerInstrumented || node instanceof this.nodeTypes.IcedRuntime;
    };

    CoffeeScriptInstrumenter.prototype.shouldInstrumentNode = function(node) {
      return !(node instanceof this.nodeTypes.IcedRuntime) && !(node instanceof this.nodeTypes.Comment) && !(node instanceof this.nodeTypes.While) && !(node instanceof this.nodeTypes.Switch) && !(node instanceof this.nodeTypes.If);
    };

    CoffeeScriptInstrumenter.prototype.compileAst = function(ast, originalCode, compileOptions) {
      var SourceMap, answer, compilerName, currentColumn, currentLine, fragment, fragments, header, i, js, len, map, newLines;
      SourceMap = this.coffee.compile("", {
        sourceMap: true
      }).sourceMap.constructor;
      if (compileOptions.sourceMap) {
        map = new SourceMap;
      }
      fragments = ast.compileToFragments(compileOptions);
      currentLine = 0;
      if (compileOptions.header) {
        currentLine += 1;
      }
      if (compileOptions.shiftLine) {
        currentLine += 1;
      }
      currentColumn = 0;
      js = "";
      for (i = 0, len = fragments.length; i < len; i++) {
        fragment = fragments[i];
        if (compileOptions.sourceMap) {
          if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
            map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
              noReplace: true
            });
          }
          newLines = this.coffee.helpers.count(fragment.code, "\n");
          currentLine += newLines;
          if (newLines) {
            currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
          } else {
            currentColumn += fragment.code.length;
          }
        }
        js += fragment.code;
      }
      if (compileOptions.header) {
        compilerName = this.coffee.iced != null ? "IcedCoffeeScript" : "CoffeeScript";
        header = "Generated by " + compilerName + " " + this.coffee.VERSION + " (instrumented by pencil-tracer)";
        js = "// " + header + "\n" + js;
      }
      if (compileOptions.sourceMap) {
        answer = {
          js: js
        };
        answer.sourceMap = map;
        answer.v3SourceMap = map.generate(compileOptions, originalCode);
        return answer;
      } else {
        return js;
      }
    };

    CoffeeScriptInstrumenter.prototype.findVariables = function(node, scopes, depth) {
      if (scopes == null) {
        scopes = [];
      }
      if (depth == null) {
        depth = 0;
      }
      if (node instanceof this.nodeTypes.Block) {
        depth += 1;
        scopes[depth] = new Scope(scopes[depth - 1]);
      }
      node.pencilTracerScope = scopes[depth];
      if (node instanceof this.nodeTypes.Assign && node.context !== "object") {
        if (node.variable.base instanceof this.nodeTypes.Literal) {
          scopes[depth].add(node.variable.base.value);
        }
      }
      node.eachChild((function(_this) {
        return function(child) {
          return _this.findVariables(child, scopes, depth);
        };
      })(this));
      if (node.icedContinuationBlock != null) {
        return this.findVariables(node.icedContinuationBlock, scopes, depth);
      }
    };

    CoffeeScriptInstrumenter.prototype.instrumentTree = function(node, parent) {
      var caseClause, childIndex, children, expression, i, instrumentedNode, len, ref, tryBlock, tryNode;
      if (parent == null) {
        parent = null;
      }
      if (this.shouldSkipNode(node)) {
        return;
      }
      if (node instanceof this.nodeTypes.Block && !(parent instanceof this.nodeTypes.Parens) && !(parent instanceof this.nodeTypes.Class)) {
        children = node.expressions;
        childIndex = 0;
        while (childIndex < children.length) {
          expression = children[childIndex];
          if (this.shouldInstrumentNode(expression)) {
            instrumentedNode = this.createInstrumentedNode(expression, "code");
            children.splice(childIndex, 0, instrumentedNode);
            childIndex++;
          }
          if (!this.shouldSkipNode(expression)) {
            this.instrumentTree(expression, node);
          }
          childIndex++;
        }
        if (parent instanceof this.nodeTypes.For) {
          instrumentedNode = this.createInstrumentedNode(parent, "code");
          return children.unshift(instrumentedNode);
        }
      } else if (node instanceof this.nodeTypes.While) {
        node.condition = this.createInstrumentedExpr(node, "code", node.condition);
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Switch) {
        node.subject = this.createInstrumentedExpr(node, "code", node.subject);
        ref = node.cases;
        for (i = 0, len = ref.length; i < len; i++) {
          caseClause = ref[i];
          caseClause[0] = this.createInstrumentedExpr(caseClause[0], "code", caseClause[0]);
        }
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.If) {
        node.condition = this.createInstrumentedExpr(node.condition, "code", node.condition);
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Code) {
        tryBlock = this.coffee.nodes("try\nfinally");
        tryNode = tryBlock.expressions[0];
        tryNode.attempt = node.body;
        tryBlock.expressions.unshift(this.createInstrumentedNode(node, "enter"));
        tryNode.ensure.expressions.unshift(this.createInstrumentedNode(node, "leave"));
        node.body = tryBlock;
        return this.instrumentTree(tryNode.attempt, tryNode);
      } else {
        node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node);
          };
        })(this));
        if (node.icedContinuationBlock != null) {
          return this.instrumentTree(node.icedContinuationBlock, node);
        }
      }
    };

    CoffeeScriptInstrumenter.prototype.instrument = function(filename, code) {
      var ast, compileOptions, err, result;
      ast = this.coffee.nodes(code);
      this.findVariables(ast);
      this.instrumentTree(ast);
      if (this.options.ast) {
        return ast;
      }
      try {
        compileOptions = {
          runtime: "inline",
          bare: this.options.bare,
          header: this.options.header,
          sourceMap: this.options.sourceMap
        };
        result = this.compileAst(ast, code, compileOptions);
      } catch (_error) {
        err = _error;
        throw new Error("Could not compile " + filename + " after instrumenting: " + err.stack);
      }
      return result;
    };

    return CoffeeScriptInstrumenter;

  })();

  exports.instrumentCoffee = function(filename, code, coffee, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new CoffeeScriptInstrumenter(coffee, options);
    return instrumenter.instrument(filename, code);
  };

}).call(this);
