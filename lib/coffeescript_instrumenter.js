// Generated by CoffeeScript 1.9.3
(function() {
  var CoffeeScriptInstrumenter;

  CoffeeScriptInstrumenter = (function() {
    function CoffeeScriptInstrumenter(coffee1) {
      this.coffee = coffee1;
      if (this.coffee == null) {
        throw new Error("A CoffeeScript compiler must be passed to CoffeeScriptInstrumenter!");
      }
      this.getNodeTypes();
    }

    CoffeeScriptInstrumenter.prototype.getNodeTypes = function() {
      var icedNodes;
      this.nodeTypes = {
        'Block': this.coffee.nodes("").constructor,
        'Literal': this.coffee.nodes("0").expressions[0].base.constructor,
        'Undefined': this.coffee.nodes("undefined").expressions[0].base.constructor,
        'Null': this.coffee.nodes("null").expressions[0].base.constructor,
        'Bool': this.coffee.nodes("true").expressions[0].base.constructor,
        'Return': this.coffee.nodes("return").expressions[0].constructor,
        'Value': this.coffee.nodes("0").expressions[0].constructor,
        'Comment': this.coffee.nodes("###\n###").expressions[0].constructor,
        'Call': this.coffee.nodes("f()").expressions[0].constructor,
        'Extends': this.coffee.nodes("A extends B").expressions[0].constructor,
        'Access': this.coffee.nodes("a.b").expressions[0].properties[0].constructor,
        'Index': this.coffee.nodes("a[0]").expressions[0].properties[0].constructor,
        'Range': this.coffee.nodes("[0..1]").expressions[0].base.constructor,
        'Slice': this.coffee.nodes("a[0..1]").expressions[0].properties[0].constructor,
        'Obj': this.coffee.nodes("{}").expressions[0].base.constructor,
        'Arr': this.coffee.nodes("[]").expressions[0].base.constructor,
        'Class': this.coffee.nodes("class").expressions[0].constructor,
        'Assign': this.coffee.nodes("a=0").expressions[0].constructor,
        'Code': this.coffee.nodes("->").expressions[0].constructor,
        'Param': this.coffee.nodes("(a)->").expressions[0].params[0].constructor,
        'Splat': this.coffee.nodes("[a...]").expressions[0].base.objects[0].constructor,
        'Expansion': this.coffee.nodes("[...]").expressions[0].base.objects[0].constructor,
        'While': this.coffee.nodes("0 while true").expressions[0].constructor,
        'Op': this.coffee.nodes("1+1").expressions[0].constructor,
        'In': this.coffee.nodes("0 in []").expressions[0].constructor,
        'Try': this.coffee.nodes("try").expressions[0].constructor,
        'Throw': this.coffee.nodes("throw 0").expressions[0].constructor,
        'Existence': this.coffee.nodes("a?").expressions[0].constructor,
        'Parens': this.coffee.nodes("(0)").expressions[0].base.constructor,
        'For': this.coffee.nodes("0 for a in []").expressions[0].constructor,
        'Switch': this.coffee.nodes("switch a\n  when 0 then 0").expressions[0].constructor,
        'If': this.coffee.nodes("0 if 0").expressions[0].constructor
      };
      if (this.coffee.iced != null) {
        icedNodes = this.coffee.nodes("await f defer a");
        this.nodeTypes.IcedRuntime = icedNodes.expressions[0].constructor;
        this.nodeTypes.Await = icedNodes.expressions[1].constructor;
        this.nodeTypes.Defer = icedNodes.expressions[1].body.expressions[0].args[0].constructor;
        return this.nodeTypes.Slot = icedNodes.expressions[1].body.expressions[0].args[0].slots[0].constructor;
      } else {
        return this.nodeTypes.IcedRuntime = this.nodeTypes.Await = this.nodeTypes.Defer = this.nodeTypes.Slot = function() {};
      }
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(traceFunc, locationData, eventType) {
      var instrumentedNode, locationObj;
      locationObj = "{ first_line: " + (locationData.first_line + 1) + ",";
      locationObj += " first_column: " + (locationData.first_column + 1) + ",";
      locationObj += " last_line: " + (locationData.last_line + 1) + ",";
      locationObj += " last_column: " + (locationData.last_column + 1) + " }";
      instrumentedNode = this.coffee.nodes(traceFunc + "({ location: " + locationObj + ", type: '" + eventType + "' })");
      return instrumentedNode.expressions[0];
    };

    CoffeeScriptInstrumenter.prototype.compileAst = function(ast, originalCode, options) {
      var SourceMap, answer, compilerName, currentColumn, currentLine, fragment, fragments, header, i, js, len, map, newLines;
      SourceMap = this.coffee.compile("", {
        sourceMap: true
      }).sourceMap.constructor;
      if (options.sourceMap) {
        map = new SourceMap;
      }
      fragments = ast.compileToFragments(options);
      currentLine = 0;
      if (options.header) {
        currentLine += 1;
      }
      if (options.shiftLine) {
        currentLine += 1;
      }
      currentColumn = 0;
      js = "";
      for (i = 0, len = fragments.length; i < len; i++) {
        fragment = fragments[i];
        if (options.sourceMap) {
          if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
            map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
              noReplace: true
            });
          }
          newLines = this.coffee.helpers.count(fragment.code, "\n");
          currentLine += newLines;
          if (newLines) {
            currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
          } else {
            currentColumn += fragment.code.length;
          }
        }
        js += fragment.code;
      }
      if (options.header) {
        compilerName = this.coffee.iced != null ? "IcedCoffeeScript" : "CoffeeScript";
        header = "Generated by " + compilerName + " " + this.coffee.VERSION + " (instrumented by pencil-tracer)";
        js = "// " + header + "\n" + js;
      }
      if (options.sourceMap) {
        answer = {
          js: js
        };
        answer.sourceMap = map;
        answer.v3SourceMap = map.generate(options, originalCode);
        return answer;
      } else {
        return js;
      }
    };

    CoffeeScriptInstrumenter.prototype.instrument = function(filename, code, options) {
      var ast, compileOptions, err, instrumentTree, ref, result, traceFunc;
      if (options == null) {
        options = {};
      }
      traceFunc = (ref = options.traceFunc) != null ? ref : "pencilTrace";
      ast = this.coffee.nodes(code);
      instrumentTree = (function(_this) {
        return function(node, parent) {
          var childIndex, children, expression, instrumentedNode, results, tryBlock, tryNode;
          if (parent == null) {
            parent = null;
          }
          if (node instanceof _this.nodeTypes.Block && !(parent instanceof _this.nodeTypes.Parens)) {
            children = node.expressions;
            childIndex = 0;
            results = [];
            while (childIndex < children.length) {
              expression = children[childIndex];
              if (!(expression instanceof _this.nodeTypes.Comment || expression instanceof _this.nodeTypes.IcedRuntime)) {
                instrumentedNode = _this.createInstrumentedNode(traceFunc, expression.locationData, "code");
                children.splice(childIndex, 0, instrumentedNode);
                childIndex++;
                instrumentTree(expression, node);
              }
              results.push(childIndex++);
            }
            return results;
          } else if (node instanceof _this.nodeTypes.Code) {
            tryBlock = _this.coffee.nodes("try\nfinally");
            tryNode = tryBlock.expressions[0];
            tryNode.attempt = node.body;
            tryBlock.expressions.unshift(_this.createInstrumentedNode(traceFunc, node.locationData, "enter"));
            tryNode.ensure.expressions.unshift(_this.createInstrumentedNode(traceFunc, node.locationData, "leave"));
            node.body = tryBlock;
            return instrumentTree(tryNode.attempt, tryNode);
          } else {
            node.eachChild(function(child) {
              return instrumentTree(child, node);
            });
            if (node.icedContinuationBlock != null) {
              return instrumentTree(node.icedContinuationBlock, node);
            }
          }
        };
      })(this);
      instrumentTree(ast);
      if (options.ast) {
        return ast;
      }
      try {
        compileOptions = {
          runtime: "inline",
          bare: options.bare,
          header: options.header,
          sourceMap: options.sourceMap
        };
        result = this.compileAst(ast, code, compileOptions);
      } catch (_error) {
        err = _error;
        throw new Error("Could not compile " + filename + " after instrumenting: " + err.stack);
      }
      return result;
    };

    return CoffeeScriptInstrumenter;

  })();

  exports.instrumentCoffee = function(filename, code, coffee, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new CoffeeScriptInstrumenter(coffee);
    return instrumenter.instrument(filename, code, options);
  };

}).call(this);
