// Generated by CoffeeScript 1.9.2
(function() {
  var umd,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  umd = function(factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return this.pencilTracer = factory();
    }
  };

  umd(function() {
    var CoffeeScriptInstrumenter, InstrumentError;
    InstrumentError = (function(superClass) {
      extend(InstrumentError, superClass);

      function InstrumentError(message) {
        this.message = message;
        this.name = "InstrumentError";
        Error.call(this);
        Error.captureStackTrace(this, arguments.callee);
      }

      return InstrumentError;

    })(Error);
    CoffeeScriptInstrumenter = (function() {
      function CoffeeScriptInstrumenter(coffee) {
        this.coffee = coffee;
        if (this.coffee == null) {
          this.coffee = require("coffee-script");
        }
      }

      CoffeeScriptInstrumenter.prototype.nodeType = function(node) {
        var ref;
        return (node != null ? (ref = node.constructor) != null ? ref.name : void 0 : void 0) || null;
      };

      CoffeeScriptInstrumenter.prototype.makeUndefinedNode = function() {
        return this.coffee.nodes("undefined").expressions[0];
      };

      CoffeeScriptInstrumenter.prototype.makeAssignNode = function(variableName, valueNode) {
        var node;
        node = this.coffee.nodes("x = 0").expressions[0];
        node.variable.base.value = variableName;
        node.value = valueNode;
        return node;
      };

      CoffeeScriptInstrumenter.prototype.makeReturnNode = function(variableName) {
        var node;
        node = this.coffee.nodes("return x").expressions[0];
        node.expression.base.value = variableName;
        return node;
      };

      CoffeeScriptInstrumenter.prototype.fixLocationData = function(instrumentedNode, lineNum) {
        var doIt;
        doIt = function(node) {
          return node.locationData = {
            first_line: lineNum,
            first_column: 0,
            last_line: lineNum,
            last_column: 0
          };
        };
        doIt(instrumentedNode);
        return instrumentedNode.eachChild(doIt);
      };

      CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(traceFunc, locationData, eventType) {
        var instrumentedNode, locationObj;
        locationObj = "{ first_line: " + (locationData.first_line + 1) + ",";
        locationObj += " first_column: " + (locationData.first_column + 1) + ",";
        locationObj += " last_line: " + (locationData.last_line + 1) + ",";
        locationObj += " last_column: " + (locationData.last_column + 1) + " }";
        instrumentedNode = this.coffee.nodes(traceFunc + "({ location: " + locationObj + ", type: '" + eventType + "' })");
        this.fixLocationData(instrumentedNode, locationData.first_line);
        return instrumentedNode;
      };

      CoffeeScriptInstrumenter.prototype.temporaryVariable = function(name, used) {
        var curName, index;
        index = 0;
        while (true) {
          curName = "" + name + index;
          if (indexOf.call(used, curName) < 0) {
            return curName;
          }
          index++;
        }
      };

      CoffeeScriptInstrumenter.prototype.instrument = function(filename, code, options) {
        var ast, err, instrumentTree, js, ref, referencedVars, token, tokens, traceFunc;
        if (options == null) {
          options = {};
        }
        traceFunc = (ref = options.traceFunc) != null ? ref : "pencilTrace";
        try {
          tokens = this.coffee.tokens(code, {});
          referencedVars = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = tokens.length; i < len; i++) {
              token = tokens[i];
              if (token.variable) {
                results.push(token[1]);
              }
            }
            return results;
          })();
          ast = this.coffee.nodes(tokens);
        } catch (_error) {
          err = _error;
          throw new InstrumentError("Could not parse " + filename + ": " + err.stack);
        }
        instrumentTree = (function(_this) {
          return function(node, nodeIndex, parent, inCode) {
            var assignNode, childIndex, children, expression, instrumentedNode, lastExpr, tempVariableName;
            if (nodeIndex == null) {
              nodeIndex = null;
            }
            if (parent == null) {
              parent = null;
            }
            if (inCode == null) {
              inCode = null;
            }
            if (_this.nodeType(node) === "Code") {
              inCode = node;
            }
            if (_this.nodeType(node) === "Block") {
              children = node.expressions;
              childIndex = 0;
              while (childIndex < children.length) {
                expression = children[childIndex];
                if (!(expression.doNotInstrument || _this.nodeType(expression) === "Comment" || _this.nodeType(expression) === "IcedRuntime")) {
                  instrumentedNode = _this.createInstrumentedNode(traceFunc, expression.locationData, "");
                  children.splice(childIndex, 0, instrumentedNode);
                  childIndex++;
                  instrumentTree(expression, childIndex, node, inCode);
                }
                childIndex++;
              }
              if (_this.nodeType(parent) === "Code") {
                children.splice(0, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "enter"));
                if (children.length === 1) {
                  children.splice(1, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "leave"));
                  return children.splice(2, 0, _this.makeUndefinedNode());
                } else {
                  lastExpr = children[children.length - 1];
                  if (!(_this.nodeType(lastExpr) === "Return" || _this.nodeType(lastExpr) === "Await")) {
                    tempVariableName = _this.temporaryVariable("_tempReturnVal", referencedVars);
                    referencedVars.push(tempVariableName);
                    assignNode = _this.makeAssignNode(tempVariableName, lastExpr);
                    children.splice(children.length - 1, 1, assignNode);
                    children.splice(children.length, 0, _this.createInstrumentedNode(traceFunc, parent.locationData, "leave"));
                    return children.splice(children.length, 0, _this.coffee.nodes(tempVariableName).expressions[0]);
                  }
                }
              }
            } else {
              if (_this.nodeType(node) === "Return" && (inCode != null)) {
                if (_this.nodeType(parent) !== "Block") {
                  throw new InstrumentError("Encountered a Return whose parent is not a Block. This is a bug, please report!");
                }
                tempVariableName = _this.temporaryVariable("_tempReturnVal", referencedVars);
                referencedVars.push(tempVariableName);
                assignNode = _this.makeAssignNode(tempVariableName, node.expression);
                parent.expressions.splice(nodeIndex, 1, assignNode);
                parent.expressions.splice(nodeIndex + 1, 0, _this.createInstrumentedNode(traceFunc, inCode.locationData, "leave"));
                parent.expressions.splice(nodeIndex + 2, 0, _this.makeReturnNode(tempVariableName));
                parent.expressions[nodeIndex].doNotInstrument = true;
                parent.expressions[nodeIndex + 1].doNotInstrument = true;
                parent.expressions[nodeIndex + 2].doNotInstrument = true;
              }
              return node.eachChild(function(child) {
                return instrumentTree(child, null, node, inCode);
              });
            }
          };
        })(this);
        instrumentTree(ast);
        if (options.ast) {
          return ast;
        }
        try {
          js = ast.compile({
            runtime: "inline"
          });
        } catch (_error) {
          err = _error;
          throw new InstrumentError("Could not compile " + filename + " after instrumenting: " + err.stack);
        }
        return js;
      };

      return CoffeeScriptInstrumenter;

    })();
    return {
      instrumentCoffee: function(filename, code, options) {
        var instrumenter;
        if (options == null) {
          options = {};
        }
        instrumenter = new CoffeeScriptInstrumenter(options.compiler);
        return instrumenter.instrument(filename, code, options);
      }
    };
  });

}).call(this);
