// Generated by CoffeeScript 1.9.3
(function() {
  var CoffeeScriptInstrumenter,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CoffeeScriptInstrumenter = (function() {
    function CoffeeScriptInstrumenter(coffee1, options1) {
      var base1;
      this.coffee = coffee1;
      this.options = options1 != null ? options1 : {};
      if (this.coffee == null) {
        throw new Error("A CoffeeScript compiler must be passed to CoffeeScriptInstrumenter!");
      }
      if ((base1 = this.options).traceFunc == null) {
        base1.traceFunc = "pencilTrace";
      }
      this.getNodeTypes();
    }

    CoffeeScriptInstrumenter.prototype.getNodeTypes = function() {
      var awaitNode, icedNodes;
      this.nodeTypes = {
        'Block': this.coffee.nodes("").constructor,
        'Literal': this.coffee.nodes("0").expressions[0].base.constructor,
        'Undefined': this.coffee.nodes("undefined").expressions[0].base.constructor,
        'Null': this.coffee.nodes("null").expressions[0].base.constructor,
        'Bool': this.coffee.nodes("true").expressions[0].base.constructor,
        'Return': this.coffee.nodes("return").expressions[0].constructor,
        'Value': this.coffee.nodes("0").expressions[0].constructor,
        'Comment': this.coffee.nodes("###\n###").expressions[0].constructor,
        'Call': this.coffee.nodes("f()").expressions[0].constructor,
        'Extends': this.coffee.nodes("A extends B").expressions[0].constructor,
        'Access': this.coffee.nodes("a.b").expressions[0].properties[0].constructor,
        'Index': this.coffee.nodes("a[0]").expressions[0].properties[0].constructor,
        'Range': this.coffee.nodes("[0..1]").expressions[0].base.constructor,
        'Slice': this.coffee.nodes("a[0..1]").expressions[0].properties[0].constructor,
        'Obj': this.coffee.nodes("{}").expressions[0].base.constructor,
        'Arr': this.coffee.nodes("[]").expressions[0].base.constructor,
        'Class': this.coffee.nodes("class").expressions[0].constructor,
        'Assign': this.coffee.nodes("a=0").expressions[0].constructor,
        'Code': this.coffee.nodes("->").expressions[0].constructor,
        'Param': this.coffee.nodes("(a)->").expressions[0].params[0].constructor,
        'Splat': this.coffee.nodes("[a...]").expressions[0].base.objects[0].constructor,
        'Expansion': this.coffee.nodes("[...]").expressions[0].base.objects[0].constructor,
        'While': this.coffee.nodes("0 while true").expressions[0].constructor,
        'Op': this.coffee.nodes("1+1").expressions[0].constructor,
        'In': this.coffee.nodes("0 in []").expressions[0].constructor,
        'Try': this.coffee.nodes("try").expressions[0].constructor,
        'Throw': this.coffee.nodes("throw 0").expressions[0].constructor,
        'Existence': this.coffee.nodes("a?").expressions[0].constructor,
        'Parens': this.coffee.nodes("(0)").expressions[0].base.constructor,
        'For': this.coffee.nodes("0 for a in []").expressions[0].constructor,
        'Switch': this.coffee.nodes("switch a\n  when 0 then 0").expressions[0].constructor,
        'If': this.coffee.nodes("0 if 0").expressions[0].constructor
      };
      if (this.coffee.iced != null) {
        icedNodes = this.coffee.nodes("if 1\n  await f defer a\n  1");
        awaitNode = icedNodes.expressions[1].body.expressions[0];
        this.nodeTypes.IcedRuntime = icedNodes.expressions[0].constructor;
        this.nodeTypes.Await = awaitNode.constructor;
        this.nodeTypes.Defer = awaitNode.body.expressions[0].args[0].constructor;
        this.nodeTypes.Slot = awaitNode.body.expressions[0].args[0].slots[0].constructor;
        return this.nodeTypes.IcedTailCall = awaitNode.icedContinuationBlock.expressions[0].constructor;
      } else {
        return this.nodeTypes.IcedRuntime = this.nodeTypes.Await = this.nodeTypes.Defer = this.nodeTypes.Slot = this.nodeTypes.IcedTailCall = function() {};
      }
    };

    CoffeeScriptInstrumenter.prototype.temporaryVariable = function(base) {
      var curName, index, name;
      name = "_penciltracer_" + base;
      index = 0;
      while (true) {
        curName = name + index;
        if (indexOf.call(this.referencedVars, curName) < 0) {
          this.referencedVars.push(curName);
          return curName;
        }
        index++;
      }
    };

    CoffeeScriptInstrumenter.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;
      while (i--) {
        if (!(list[i] instanceof this.nodeTypes.Comment)) {
          return list[i];
        }
      }
      return null;
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedNode = function(targetNode, eventType, returnOrThrowVar) {
      var eventObj, extra, instrumentedNode, locationData, locationObj, name;
      if (targetNode instanceof this.nodeTypes.IcedTailCall) {
        targetNode = targetNode.value;
      }
      locationData = targetNode.locationData;
      locationObj = "{ first_line: " + (locationData.first_line + 1) + ",";
      locationObj += " first_column: " + (locationData.first_column + 1) + ",";
      locationObj += " last_line: " + (locationData.last_line + 1) + ",";
      locationObj += " last_column: " + (locationData.last_column + 1) + " }";
      extra = (function() {
        switch (eventType) {
          case "before":
          case "after":
            return "vars: {" + ((function() {
              var j, len, ref, results;
              ref = this.findVariables(targetNode);
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                name = ref[j];
                results.push(name + ": (if typeof " + name + " is 'undefined' then undefined else " + name + ")");
              }
              return results;
            }).call(this)) + "}";
          case "enter":
            return "vars: {" + ((function() {
              var j, len, ref, results;
              ref = this.findArguments(targetNode);
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                name = ref[j];
                results.push(name + ": " + name);
              }
              return results;
            }).call(this)) + "}";
          case "leave":
            return "returnOrThrow: " + returnOrThrowVar;
        }
      }).call(this);
      eventObj = "{ location: " + locationObj + ", type: '" + eventType + "', " + extra + " }";
      instrumentedNode = this.coffee.nodes(this.options.traceFunc + "(" + eventObj + ")").expressions[0];
      instrumentedNode.pencilTracerInstrumented = true;
      return instrumentedNode;
    };

    CoffeeScriptInstrumenter.prototype.createInstrumentedExpr = function(targetNode, originalExpr) {
      var assignNode, parensBlock, tempVar;
      tempVar = this.temporaryVariable("temp");
      assignNode = this.coffee.nodes(tempVar + " = 0").expressions[0];
      assignNode.value = originalExpr;
      parensBlock = this.coffee.nodes("(0)").expressions[0];
      parensBlock.base.body.expressions = [];
      parensBlock.base.body.expressions[0] = this.createInstrumentedNode(targetNode, "before");
      parensBlock.base.body.expressions[1] = assignNode;
      parensBlock.base.body.expressions[2] = this.createInstrumentedNode(targetNode, "after");
      parensBlock.base.body.expressions[3] = this.coffee.nodes(tempVar).expressions[0];
      return parensBlock;
    };

    CoffeeScriptInstrumenter.prototype.findVariables = function(node, parent, vars) {
      var skip;
      if (parent == null) {
        parent = null;
      }
      if (vars == null) {
        vars = [];
      }
      if (!node) {
        return [];
      }
      if (node instanceof this.nodeTypes.Value && node.base instanceof this.nodeTypes.Literal && node.base.isAssignable()) {
        skip = parent instanceof this.nodeTypes.Assign && parent.context === "object" && parent.variable === node;
        if (!skip) {
          if (vars.indexOf(node.base.value) === -1) {
            vars.push(node.base.value);
          }
        }
      }
      node.eachChild((function(_this) {
        return function(child) {
          if (!(child instanceof _this.nodeTypes.Block)) {
            return _this.findVariables(child, node, vars);
          }
        };
      })(this));
      return vars;
    };

    CoffeeScriptInstrumenter.prototype.findArguments = function(codeNode) {
      var args, j, len, name, paramNode, ref, results;
      if (!(codeNode instanceof this.nodeTypes.Code)) {
        throw new Error("findArguments() expects a Code node");
      }
      args = [];
      ref = codeNode.params;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        paramNode = ref[j];
        name = paramNode.name;
        if (name instanceof this.nodeTypes.Literal) {
          results.push(args.push(name.value));
        } else if (name instanceof this.nodeTypes.Value) {

        } else {
          results.push(args.push.apply(args, this.findVariables(name)));
        }
      }
      return results;
    };

    CoffeeScriptInstrumenter.prototype.nodeIsObj = function(node) {
      return node instanceof this.nodeTypes.Value && node.isObject(true);
    };

    CoffeeScriptInstrumenter.prototype.nodeIsClassProperty = function(node, className) {
      return this.nodeIsObj(node) || (node instanceof this.nodeTypes.Assign && node.variable.looksStatic(className)) || (node instanceof this.nodeTypes.Assign && node.variable["this"]);
    };

    CoffeeScriptInstrumenter.prototype.shouldSkipNode = function(node) {
      return node.pencilTracerInstrumented || node instanceof this.nodeTypes.IcedRuntime;
    };

    CoffeeScriptInstrumenter.prototype.shouldInstrumentNode = function(node) {
      return !node.pencilTracerInstrumented && !(node instanceof this.nodeTypes.IcedRuntime) && (!(node instanceof this.nodeTypes.IcedTailCall) || node.value) && !(node instanceof this.nodeTypes.Comment) && !(node instanceof this.nodeTypes.While) && !(node instanceof this.nodeTypes.Switch) && !(node instanceof this.nodeTypes.If);
    };

    CoffeeScriptInstrumenter.prototype.compileAst = function(ast, originalCode, compileOptions) {
      var SourceMap, answer, compilerName, currentColumn, currentLine, fragment, fragments, header, j, js, len, map, newLines;
      SourceMap = this.coffee.compile("", {
        sourceMap: true
      }).sourceMap.constructor;
      if (compileOptions.sourceMap) {
        map = new SourceMap;
      }
      fragments = ast.compileToFragments(compileOptions);
      currentLine = 0;
      if (compileOptions.header) {
        currentLine += 1;
      }
      if (compileOptions.shiftLine) {
        currentLine += 1;
      }
      currentColumn = 0;
      js = "";
      for (j = 0, len = fragments.length; j < len; j++) {
        fragment = fragments[j];
        if (compileOptions.sourceMap) {
          if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
            map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
              noReplace: true
            });
          }
          newLines = this.coffee.helpers.count(fragment.code, "\n");
          currentLine += newLines;
          if (newLines) {
            currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
          } else {
            currentColumn += fragment.code.length;
          }
        }
        js += fragment.code;
      }
      if (compileOptions.header) {
        compilerName = this.coffee.iced != null ? "IcedCoffeeScript" : "CoffeeScript";
        header = "Generated by " + compilerName + " " + this.coffee.VERSION + " (instrumented by pencil-tracer)";
        js = "// " + header + "\n" + js;
      }
      if (compileOptions.sourceMap) {
        answer = {
          js: js
        };
        answer.sourceMap = map;
        answer.v3SourceMap = map.generate(compileOptions, originalCode);
        return answer;
      } else {
        return js;
      }
    };

    CoffeeScriptInstrumenter.prototype.instrumentTree = function(node, parent, inClass, returnOrThrowVar) {
      var afterNode, assignNode, beforeNode, block, caseClause, childIndex, children, expression, instrumentedNode, j, lastChild, len, ref, tryNode;
      if (parent == null) {
        parent = null;
      }
      if (inClass == null) {
        inClass = false;
      }
      if (this.shouldSkipNode(node)) {
        return;
      }
      if (node instanceof this.nodeTypes.Class) {
        inClass = node;
      }
      if (this.nodeIsObj(node)) {
        inClass = false;
      }
      if (node instanceof this.nodeTypes.Block && !(parent instanceof this.nodeTypes.Parens)) {
        children = node.expressions;
        lastChild = this.lastNonComment(children);
        childIndex = 0;
        if (!returnOrThrowVar) {
          returnOrThrowVar = this.temporaryVariable("returnOrThrow");
          children.unshift(this.coffee.nodes(returnOrThrowVar + " = {}").expressions[0]);
          childIndex = 1;
        }
        while (childIndex < children.length) {
          expression = children[childIndex];
          if (this.shouldInstrumentNode(expression)) {
            beforeNode = this.createInstrumentedNode(expression, "before");
            afterNode = this.createInstrumentedNode(expression, "after");
            children.splice(childIndex, 0, beforeNode);
            childIndex++;
            children.splice(childIndex + 1, 0, afterNode);
            childIndex++;
            if (expression === lastChild && !expression.jumps() && !(expression instanceof this.nodeTypes.Await) && !(inClass && this.nodeIsClassProperty(expression, inClass.determineName()))) {
              assignNode = this.coffee.nodes(returnOrThrowVar + ".value = 0").expressions[0];
              assignNode.value = expression;
              children[childIndex - 1] = assignNode;
              children.splice(childIndex + 1, 0, this.coffee.nodes(returnOrThrowVar + ".value").expressions[0]);
              children[childIndex + 1].icedHasAutocbFlag = expression.icedHasAutocbFlag;
              childIndex++;
            } else if (expression instanceof this.nodeTypes.Return) {
              assignNode = this.coffee.nodes(returnOrThrowVar + ".value = 0").expressions[0];
              assignNode.value = expression.expression || this.coffee.nodes("undefined").expressions[0];
              children[childIndex - 1] = assignNode;
              children.splice(childIndex + 1, 0, this.coffee.nodes("return " + returnOrThrowVar + ".value").expressions[0]);
              childIndex++;
            }
          }
          this.instrumentTree(expression, node, inClass, returnOrThrowVar);
          childIndex++;
        }
        if (parent instanceof this.nodeTypes.For) {
          instrumentedNode = this.createInstrumentedNode(parent, "before");
          return children.unshift(instrumentedNode);
        }
      } else if (node instanceof this.nodeTypes.While) {
        node.condition = this.createInstrumentedExpr(node, node.condition);
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Switch) {
        if (node.subject) {
          node.subject = this.createInstrumentedExpr(node, node.subject);
        }
        ref = node.cases;
        for (j = 0, len = ref.length; j < len; j++) {
          caseClause = ref[j];
          if (caseClause[0] instanceof Array) {
            caseClause[0][0] = this.createInstrumentedExpr(caseClause[0][0], caseClause[0][0]);
          } else {
            caseClause[0] = this.createInstrumentedExpr(caseClause[0], caseClause[0]);
          }
        }
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.If) {
        node.condition = this.createInstrumentedExpr(node.condition, node.condition);
        return node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
      } else if (node instanceof this.nodeTypes.Code) {
        returnOrThrowVar = this.temporaryVariable("returnOrThrow");
        block = this.coffee.nodes(returnOrThrowVar + " = { type: 'return', value: undefined }\ntry\ncatch " + this.caughtErrorVar + "\n  " + returnOrThrowVar + ".type = 'throw'\n  " + returnOrThrowVar + ".value = " + this.caughtErrorVar + "\n  throw " + this.caughtErrorVar + "\nfinally");
        tryNode = block.expressions[1];
        tryNode.attempt = node.body;
        block.expressions.unshift(this.createInstrumentedNode(node, "enter"));
        tryNode.ensure.expressions.unshift(this.createInstrumentedNode(node, "leave", returnOrThrowVar));
        node.body = block;
        return this.instrumentTree(tryNode.attempt, tryNode, inClass, returnOrThrowVar);
      } else {
        node.eachChild((function(_this) {
          return function(child) {
            return _this.instrumentTree(child, node, inClass, returnOrThrowVar);
          };
        })(this));
        if (node.icedContinuationBlock != null) {
          return this.instrumentTree(node.icedContinuationBlock, node, inClass, returnOrThrowVar);
        }
      }
    };

    CoffeeScriptInstrumenter.prototype.instrument = function(filename, code) {
      var ast, csOptions, result, token;
      csOptions = {
        runtime: "inline",
        bare: this.options.bare,
        header: this.options.header,
        sourceMap: this.options.sourceMap,
        literate: this.options.literate
      };
      this.referencedVars = csOptions.referencedVars = (function() {
        var j, len, ref, results;
        ref = this.coffee.tokens(code, csOptions);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          token = ref[j];
          if (token.variable) {
            results.push(token[1]);
          }
        }
        return results;
      }).call(this);
      this.caughtErrorVar = this.temporaryVariable("err");
      ast = this.coffee.nodes(code, csOptions);
      this.instrumentTree(ast);
      if (this.options.ast) {
        return ast;
      }
      result = this.compileAst(ast, code, csOptions);
      return result;
    };

    return CoffeeScriptInstrumenter;

  })();

  exports.instrumentCoffee = function(filename, code, coffee, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new CoffeeScriptInstrumenter(coffee, options);
    return instrumenter.instrument(filename, code);
  };

}).call(this);
