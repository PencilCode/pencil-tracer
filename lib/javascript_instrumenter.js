// Generated by CoffeeScript 1.9.3
(function() {
  var JavaScriptInstrumenter, STATEMENTS, STATEMENTS_WITH_BODIES, falafel, isArray,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  falafel = require("falafel");

  STATEMENTS = ["EmptyStatement", "BlockStatement", "ExpressionStatement", "IfStatement", "LabeledStatement", "BreakStatement", "ContinueStatement", "WithStatement", "SwitchStatement", "ReturnStatement", "ThrowStatement", "TryStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "DebuggerStatement", "FunctionDeclaration", "VariableDeclaration"];

  STATEMENTS_WITH_BODIES = ["IfStatement", "LabeledStatement", "WithStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement"];

  isArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  JavaScriptInstrumenter = (function() {
    function JavaScriptInstrumenter(options1) {
      var base;
      this.options = options1;
      if ((base = this.options).traceFunc == null) {
        base.traceFunc = "pencilTrace";
      }
    }

    JavaScriptInstrumenter.prototype.findVariables = function(node, vars) {
      var child, i, key, len, ref, ref1, ref2;
      if (vars == null) {
        vars = [];
      }
      if (node.type === "Identifier") {
        if (vars.indexOf(node.name) === -1) {
          vars.push(node.name);
        }
      }
      for (key in node) {
        if (key === "parent") {
          continue;
        }
        if (node.type === "Property" && key === "key") {
          continue;
        }
        if (((ref = node.type) === "FunctionExpression" || ref === "FunctionDeclaration") && key === "params") {
          continue;
        }
        if (isArray(node[key])) {
          ref1 = node[key];
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            this.findVariables(child, vars);
          }
        } else if (node[key] && typeof node[key].type === "string" && (ref2 = node[key].type, indexOf.call(STATEMENTS, ref2) < 0)) {
          this.findVariables(node[key], vars);
        }
      }
      return vars;
    };

    JavaScriptInstrumenter.prototype.findArguments = function(funcNode, vars) {
      var i, len, param, ref, results;
      if (vars == null) {
        vars = [];
      }
      ref = funcNode.params;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        param = ref[i];
        results.push(param.name);
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.traceCall = function(targetNode, eventType) {
      var extra, loc, locationObj, name;
      loc = targetNode.loc;
      locationObj = "{ first_line: " + loc.start.line + ",";
      locationObj += " first_column: " + (loc.start.column + 1) + ",";
      locationObj += " last_line: " + loc.end.line + ",";
      locationObj += " last_column: " + (loc.end.column + 1) + " }";
      extra = (function() {
        switch (eventType) {
          case "before":
          case "after":
            return "vars: {" + ((function() {
              var i, len, ref, results;
              ref = this.findVariables(targetNode);
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                name = ref[i];
                results.push(name + ": (typeof " + name + " === 'undefined' ? void 0 : " + name + ")");
              }
              return results;
            }).call(this)) + "}";
          case "enter":
            return "vars: {" + ((function() {
              var i, len, ref, results;
              ref = this.findArguments(targetNode);
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                name = ref[i];
                results.push(name + ": " + name);
              }
              return results;
            }).call(this)) + "}";
          case "leave":
            return "returnVal: 'TEST'";
        }
      }).call(this);
      return this.options.traceFunc + "({ location: " + locationObj + ", type: '" + eventType + "', " + extra + " })";
    };

    JavaScriptInstrumenter.prototype.needsBraces = function(node) {
      var ref, ref1;
      return (ref = node.type, indexOf.call(STATEMENTS, ref) >= 0) && node.type !== "BlockStatement" && (ref1 = node.parent.type, indexOf.call(STATEMENTS_WITH_BODIES, ref1) >= 0) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !(node.parent.type === "ForInStatement" && node.parent.left === node);
    };

    JavaScriptInstrumenter.prototype.instrument = function(filename, code) {
      var result;
      result = falafel(code, {
        locations: true
      }, (function(_this) {
        return function(node) {
          var enter, leave, ref, ref1, ref2, ref3, ref4;
          switch (node.type) {
            case "EmptyStatement":
            case "ExpressionStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "DebuggerStatement":
            case "FunctionDeclaration":
              code = _this.traceCall(node, "before");
              node.update(code + "; " + (node.source()));
              if ((ref = node.parent.type) === "DoWhileStatement" || ref === "ForInStatement") {
                code = _this.traceCall(node.parent, "before");
                node.update(code + "; " + (node.source()));
              }
              break;
            case "VariableDeclaration":
              if ((ref1 = node.parent.type) !== "ForStatement" && ref1 !== "ForInStatement") {
                code = _this.traceCall(node, "before");
                node.update(code + "; " + (node.source()));
              }
              break;
            case "ForStatement":
              code = _this.traceCall(node.init || node, "before");
              node.update(code + "; " + (node.source()));
              break;
            case "BlockStatement":
              if ((ref2 = node.parent.type) === "FunctionDeclaration" || ref2 === "FunctionExpression") {
                enter = _this.traceCall(node.parent, "enter");
                leave = _this.traceCall(node.parent, "leave");
                node.update("{ " + enter + "; try " + (node.source()) + " finally { " + leave + "; } }");
              }
              if (node.parent.type === "TryStatement") {
                if (node.parent.block === node) {
                  code = _this.traceCall(node.parent, "before");
                  node.update("{ " + code + "; " + (node.source()) + " }");
                } else if (node.parent.finalizer === node) {
                  code = _this.traceCall(node, "before");
                  node.update("{ " + code + "; " + (node.source()) + " }");
                }
              }
              if (node.parent.type === "CatchClause") {
                code = _this.traceCall(node.parent, "before");
                node.update("{ " + code + "; " + (node.source()) + " }");
              }
              if ((ref3 = node.parent.type) === "DoWhileStatement" || ref3 === "ForInStatement") {
                code = _this.traceCall(node.parent, "before");
                node.update("{ " + code + "; " + (node.source()) + " }");
              }
              break;
            case "ThisExpression":
            case "ArrayExpression":
            case "ObjectExpression":
            case "FunctionExpression":
            case "SequenceExpression":
            case "UnaryExpression":
            case "BinaryExpression":
            case "AssignmentExpression":
            case "UpdateExpression":
            case "LogicalExpression":
            case "ConditionalExpression":
            case "CallExpression":
            case "NewExpression":
            case "MemberExpression":
            case "Identifier":
            case "Literal":
            case "RegExpLiteral":
              if ((ref4 = node.parent.type) === "IfStatement" || ref4 === "WithStatement" || ref4 === "SwitchStatement" || ref4 === "WhileStatement" || ref4 === "DoWhileStatement" || ref4 === "ForStatement" || ref4 === "SwitchCase") {
                code = _this.traceCall(node, "before");
                node.update(code + ",(" + (node.source()) + ")");
              }
          }
          if (_this.needsBraces(node)) {
            return node.update("{ " + (node.source()) + " }");
          }
        };
      })(this));
      return result.toString();
    };

    return JavaScriptInstrumenter;

  })();

  exports.instrumentJs = function(filename, code, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new JavaScriptInstrumenter(options);
    return instrumenter.instrument(filename, code);
  };

}).call(this);
