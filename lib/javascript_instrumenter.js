// Generated by CoffeeScript 1.9.3
(function() {
  var JavaScriptInstrumenter, acorn, escodegen, isArray,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  acorn = require("acorn");

  escodegen = require("escodegen");

  isArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  JavaScriptInstrumenter = (function() {
    function JavaScriptInstrumenter(options1) {
      var base1;
      this.options = options1;
      if ((base1 = this.options).traceFunc == null) {
        base1.traceFunc = "pencilTrace";
      }
    }

    JavaScriptInstrumenter.prototype.temporaryVariable = function(base, needsDeclaration) {
      var curName, index, name;
      if (needsDeclaration == null) {
        needsDeclaration = false;
      }
      name = "_penciltracer_" + base;
      index = 0;
      while (true) {
        curName = name + index;
        if (indexOf.call(this.referencedVars, curName) < 0) {
          this.referencedVars.push(curName);
          if (needsDeclaration) {
            this.undeclaredVars.push(curName);
          }
          return curName;
        }
        index++;
      }
    };

    JavaScriptInstrumenter.prototype.createInstrumentedNode = function(eventType, options) {
      var eventObj, extra, f, functionCalls, instrumentedNode, loc, locationObj, name, ref, ref1, ref2, soakify, vars;
      if (options == null) {
        options = {};
      }
      loc = (ref = options.loc) != null ? ref : options.node.loc;
      if (eventType !== "leave") {
        vars = (ref1 = options.vars) != null ? ref1 : (eventType === "enter" ? this.findArguments(options.node) : this.findVariables(options.node));
      }
      if (eventType === "after") {
        functionCalls = (ref2 = options.functionCalls) != null ? ref2 : this.findFunctionCalls(options.node);
      }
      locationObj = "{ first_line: " + loc.start.line + ",";
      locationObj += " first_column: " + (loc.start.column + 1) + ",";
      locationObj += " last_line: " + loc.end.line + ",";
      locationObj += " last_column: " + (loc.end.column + 1) + " }";
      soakify = function(name) {
        if (name.indexOf(".") === -1) {
          return "(typeof " + name + " === 'undefined' ? void 0 : " + name + ")";
        } else {
          throw "todo";
        }
      };
      extra = (function() {
        switch (eventType) {
          case "before":
          case "after":
            return "vars: [" + ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = vars.length; j < len; j++) {
                name = vars[j];
                results.push("{name: '" + name + "', value: " + (soakify(name)) + "}");
              }
              return results;
            })()) + "]";
          case "enter":
            return "vars: [" + ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = vars.length; j < len; j++) {
                name = vars[j];
                results.push("{name: '" + name + "', value: " + name + "}");
              }
              return results;
            })()) + "]";
          case "leave":
            return "returnOrThrow: " + options.returnOrThrowVar;
        }
      })();
      if (eventType === "after") {
        extra += ", functionCalls: [" + ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = functionCalls.length; j < len; j++) {
            f = functionCalls[j];
            results.push("{name: '" + f.name + "', value: " + f.tempVar + "}");
          }
          return results;
        })()) + "]";
      }
      eventObj = "{location: " + locationObj + ", type: '" + eventType + "', " + extra + "}";
      instrumentedNode = acorn.parse(this.options.traceFunc + "(" + eventObj + ");").body[0];
      instrumentedNode.pencilTracerInstrumented = true;
      instrumentedNode.expression.pencilTracerInstrumented = true;
      return instrumentedNode;
    };

    JavaScriptInstrumenter.prototype.createInstrumentedExpr = function(originalExpr) {
      var sequenceExpr, tempVar;
      tempVar = this.temporaryVariable("temp", true);
      sequenceExpr = {
        type: "SequenceExpression",
        expressions: []
      };
      sequenceExpr.expressions.push(this.createInstrumentedNode("before", {
        node: originalExpr
      }).expression);
      sequenceExpr.expressions.push(this.createAssignNode(tempVar, originalExpr));
      sequenceExpr.expressions.push(this.createInstrumentedNode("after", {
        node: originalExpr
      }).expression);
      sequenceExpr.expressions.push({
        type: "Identifier",
        name: tempVar
      });
      return sequenceExpr;
    };

    JavaScriptInstrumenter.prototype.createAssignNode = function(varName, expr) {
      return {
        type: "AssignmentExpression",
        operator: "=",
        left: {
          type: "Identifier",
          name: varName
        },
        right: expr
      };
    };

    JavaScriptInstrumenter.prototype.findVariables = function(node, vars) {
      var child, j, key, len, ref, ref1;
      if (vars == null) {
        vars = [];
      }
      if (node.type === "Identifier") {
        if (vars.indexOf(node.name) === -1) {
          vars.push(node.name);
        }
      }
      for (key in node) {
        if (node.type === "Property" && key === "key") {
          continue;
        }
        if (((ref = node.type) === "FunctionExpression" || ref === "FunctionDeclaration") && key === "params") {
          continue;
        }
        if (isArray(node[key])) {
          ref1 = node[key];
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            this.findVariables(child, vars);
          }
        } else if (node[key] && typeof node[key].type === "string") {
          this.findVariables(node[key], vars);
        }
      }
      return vars;
    };

    JavaScriptInstrumenter.prototype.findArguments = function(funcNode) {
      var j, len, param, ref, results;
      ref = funcNode.params;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        results.push(param.name);
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.findFunctionCalls = function(node, parent, grandparent, vars) {
      if (parent == null) {
        parent = null;
      }
      if (grandparent == null) {
        grandparent = null;
      }
      if (vars == null) {
        vars = [];
      }
      return [];
    };

    JavaScriptInstrumenter.prototype.shouldInstrumentWithBlock = function(node, parent) {
      var ref;
      return ((ref = node.type) === "EmptyStatement" || ref === "ExpressionStatement" || ref === "DebuggerStatement" || ref === "VariableDeclaration" || ref === "FunctionDeclaration") && !(parent.type === "ForStatement" && parent.init === node) && !(parent.type === "ForInStatement" && parent.left === node);
    };

    JavaScriptInstrumenter.prototype.shouldInstrumentExpr = function(node, parent) {
      return (parent.type === "IfStatement" && parent.test === node) || (parent.type === "WithStatement" && parent.object === node) || (parent.type === "SwitchStatement" && parent.discriminant === node) || (parent.type === "WhileStatement" && parent.test === node) || (parent.type === "DoWhileStatement" && parent.test === node) || (parent.type === "ForStatement" && parent.test === node) || (parent.type === "ForStatement" && parent.update === node) || (parent.type === "SwitchCase" && parent.test === node);
    };

    JavaScriptInstrumenter.prototype.mapChildren = function(node, func) {
      var child, i, key, results;
      results = [];
      for (key in node) {
        if (isArray(node[key])) {
          results.push((function() {
            var j, len, ref, results1;
            ref = node[key];
            results1 = [];
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              child = ref[i];
              results1.push(node[key][i] = func(child));
            }
            return results1;
          })());
        } else if (node[key] && node[key].type) {
          results.push(node[key] = func(node[key]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.instrumentTree = function(node, parent, returnOrThrowVar) {
      var ref;
      if (parent == null) {
        parent = null;
      }
      if ((ref = node.type) === "FunctionDeclaration" || ref === "FunctionExpression") {
        returnOrThrowVar = this.temporaryVariable("returnOrThrow");
      }
      return this.mapChildren(node, (function(_this) {
        return function(child) {
          var newBlock, ref1, tryStatement;
          _this.instrumentTree(child, node, returnOrThrowVar);
          if (_this.shouldInstrumentWithBlock(child, node)) {
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: child
                }), child, _this.createInstrumentedNode("after", {
                  node: child
                })
              ]
            };
          } else if (_this.shouldInstrumentExpr(child, node)) {
            return _this.createInstrumentedExpr(child);
          } else if (((ref1 = node.type) === "FunctionDeclaration" || ref1 === "FunctionExpression") && node.body === child) {
            newBlock = acorn.parse("{\n  var " + returnOrThrowVar + " = { type: 'return', value: void 0 };\n  try {}\n  catch (" + _this.caughtErrorVar + ") {\n    " + returnOrThrowVar + ".type = 'throw';\n    " + returnOrThrowVar + ".value = " + _this.caughtErrorVar + ";\n    throw " + _this.caughtErrorVar + ";\n  } finally {}\n}").body[0];
            tryStatement = newBlock.body[1];
            tryStatement.block = child;
            newBlock.body.unshift(_this.createInstrumentedNode("enter", {
              node: node
            }));
            tryStatement.finalizer.body.unshift(_this.createInstrumentedNode("leave", {
              node: node,
              returnOrThrowVar: returnOrThrowVar
            }));
            return newBlock;
          } else {
            return child;
          }
        };
      })(this));
    };

    JavaScriptInstrumenter.prototype.instrument = function(filename, code) {
      var ast, name, tempVarsDeclaration;
      this.undeclaredVars = [];
      this.referencedVars = [];
      ast = acorn.parse(code, {
        locations: true,
        onToken: (function(_this) {
          return function(token) {
            if (token.type.label === "name" && _this.referencedVars.indexOf(token.value) === -1) {
              return _this.referencedVars.push(token.value);
            }
          };
        })(this)
      });
      this.caughtErrorVar = this.temporaryVariable("err");
      this.instrumentTree(ast);
      if (this.undeclaredVars.length > 0) {
        tempVarsDeclaration = {
          type: "VariableDeclaration",
          kind: "var",
          declarations: (function() {
            var j, len, ref, results;
            ref = this.undeclaredVars;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              name = ref[j];
              results.push({
                type: "VariableDeclarator",
                id: {
                  type: "Identifier",
                  name: name
                },
                init: null
              });
            }
            return results;
          }).call(this)
        };
        ast.body.unshift(tempVarsDeclaration);
      }
      if (this.options.ast) {
        return ast;
      }
      return escodegen.generate(ast);
    };

    return JavaScriptInstrumenter;

  })();

  exports.instrumentJs = function(filename, code, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new JavaScriptInstrumenter(options);
    return instrumenter.instrument(filename, code);
  };

}).call(this);
