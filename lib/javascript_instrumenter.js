// Generated by CoffeeScript 1.9.3
(function() {
  var JavaScriptInstrumenter, STATEMENTS, STATEMENTS_WITH_BODIES, falafel,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  falafel = require("falafel");

  STATEMENTS = ["EmptyStatement", "BlockStatement", "ExpressionStatement", "IfStatement", "LabeledStatement", "BreakStatement", "ContinueStatement", "WithStatement", "SwitchStatement", "ReturnStatement", "ThrowStatement", "TryStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "DebuggerStatement", "FunctionDeclaration", "VariableDeclaration"];

  STATEMENTS_WITH_BODIES = ["IfStatement", "LabeledStatement", "WithStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement"];

  JavaScriptInstrumenter = (function() {
    function JavaScriptInstrumenter() {}

    JavaScriptInstrumenter.prototype.traceCall = function(traceFunc, location, eventType) {
      var locationObj;
      locationObj = "{ first_line: " + location.start.line + ",";
      locationObj += " first_column: " + (location.start.column + 1) + ",";
      locationObj += " last_line: " + location.end.line + ",";
      locationObj += " last_column: " + (location.end.column + 1) + " }";
      return traceFunc + "({ location: " + locationObj + ", type: '" + eventType + "' })";
    };

    JavaScriptInstrumenter.prototype.needsBraces = function(node) {
      var ref, ref1;
      return (ref = node.type, indexOf.call(STATEMENTS, ref) >= 0) && node.type !== "BlockStatement" && (ref1 = node.parent.type, indexOf.call(STATEMENTS_WITH_BODIES, ref1) >= 0) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !(node.parent.type === "ForInStatement" && node.parent.left === node);
    };

    JavaScriptInstrumenter.prototype.instrument = function(filename, code, options) {
      var ref, result, traceFunc;
      if (options == null) {
        options = {};
      }
      traceFunc = (ref = options.traceFunc) != null ? ref : "pencilTrace";
      result = falafel(code, {
        locations: true
      }, (function(_this) {
        return function(node) {
          var enter, leave, ref1, ref2, ref3;
          switch (node.type) {
            case "EmptyStatement":
            case "ExpressionStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "DebuggerStatement":
            case "FunctionDeclaration":
              code = _this.traceCall(traceFunc, node.loc, "code");
              node.update(code + "; " + (node.source()));
              break;
            case "VariableDeclaration":
              if ((ref1 = node.parent.type) !== "ForStatement" && ref1 !== "ForInStatement") {
                code = _this.traceCall(traceFunc, node.loc, "code");
                node.update(code + "; " + (node.source()));
              }
              break;
            case "ForStatement":
              if (node.init) {
                code = _this.traceCall(traceFunc, node.init.loc, "code");
                node.update(code + "; " + (node.source()));
              }
              break;
            case "BlockStatement":
              if ((ref2 = node.parent.type) === "FunctionDeclaration" || ref2 === "FunctionExpression") {
                enter = _this.traceCall(traceFunc, node.loc, "enter");
                leave = _this.traceCall(traceFunc, node.loc, "leave");
                node.update("{ " + enter + "; try " + (node.source()) + " finally { " + leave + "; } }");
              }
              break;
            case "ThisExpression":
            case "ArrayExpression":
            case "ObjectExpression":
            case "FunctionExpression":
            case "SequenceExpression":
            case "UnaryExpression":
            case "BinaryExpression":
            case "AssignmentExpression":
            case "UpdateExpression":
            case "LogicalExpression":
            case "ConditionalExpression":
            case "CallExpression":
            case "NewExpression":
            case "MemberExpression":
            case "Identifier":
            case "Literal":
            case "RegExpLiteral":
              if ((ref3 = node.parent.type) === "IfStatement" || ref3 === "WithStatement" || ref3 === "SwitchStatement" || ref3 === "WhileStatement" || ref3 === "DoWhileStatement" || ref3 === "ForStatement" || ref3 === "SwitchCase") {
                code = _this.traceCall(traceFunc, node.loc, "code");
                node.update(code + ",(" + (node.source()) + ")");
              }
          }
          if (_this.needsBraces(node)) {
            return node.update("{ " + (node.source()) + " }");
          }
        };
      })(this));
      return result.toString();
    };

    return JavaScriptInstrumenter;

  })();

  exports.instrumentJs = function(filename, code, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new JavaScriptInstrumenter();
    return instrumenter.instrument(filename, code, options);
  };

}).call(this);
