// Generated by CoffeeScript 1.9.3
(function() {
  var FIND_VARIABLES_IN, JavaScriptInstrumenter, acorn, escodegen, isArray,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  acorn = require("acorn");

  escodegen = require("escodegen");

  FIND_VARIABLES_IN = ["ThisExpression", "ArrayExpression", "ObjectExpression", "Property", "SequenceExpression", "UnaryExpression", "BinaryExpression", "AssignmentExpression", "UpdateExpression", "LogicalExpression", "ConditionalExpression", "CallExpression", "NewExpression", "MemberExpression", "Identifier", "VariableDeclarator"];

  isArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  JavaScriptInstrumenter = (function() {
    function JavaScriptInstrumenter(options1) {
      var base1;
      this.options = options1 != null ? options1 : {};
      if ((base1 = this.options).traceFunc == null) {
        base1.traceFunc = "pencilTrace";
      }
    }

    JavaScriptInstrumenter.prototype.temporaryVariable = function(base, needsDeclaration) {
      var curName, index, name;
      if (needsDeclaration == null) {
        needsDeclaration = false;
      }
      name = "_penciltracer_" + base;
      index = 0;
      while (true) {
        curName = name + index;
        if (indexOf.call(this.referencedVars, curName) < 0) {
          this.referencedVars.push(curName);
          if (needsDeclaration) {
            this.undeclaredVars.push(curName);
          }
          return curName;
        }
        index++;
      }
    };

    JavaScriptInstrumenter.prototype.isFunctionDef = function(node) {
      var ref;
      return (node != null ? node.type : void 0) === "FunctionDeclaration" || ((node != null ? node.type : void 0) === "VariableDeclaration" && node.declarations.length === 1 && ((ref = node.declarations[0].init) != null ? ref.type : void 0) === "FunctionExpression");
    };

    JavaScriptInstrumenter.prototype.soakify = function(name) {
      var closeParens, expr, i, j, parts, ref, soakified;
      soakified = "";
      closeParens = "";
      parts = name.split(".");
      for (i = j = 0, ref = parts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        expr = parts.slice(0, +i + 1 || 9e9).join(".");
        if (i === 0) {
          expr = "(typeof " + expr + " === 'undefined' ? void 0 : " + expr + ")";
        }
        if (i === parts.length - 1) {
          soakified += expr;
        } else {
          soakified += "((typeof " + expr + " === 'undefined' || " + expr + " === null) ? " + expr + " : ";
          closeParens += ")";
        }
      }
      return soakified + closeParens;
    };

    JavaScriptInstrumenter.prototype.quoteString = function(str) {
      return str.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\n");
    };

    JavaScriptInstrumenter.prototype.createInstrumentedNode = function(eventType, options) {
      var eventObj, extra, f, funcDef, functionCalls, instrumentedNode, loc, locationObj, name, ref, ref1, ref2, vars;
      if (options == null) {
        options = {};
      }
      loc = (ref = options.loc) != null ? ref : options.node.loc;
      if (eventType !== "leave") {
        vars = (ref1 = options.vars) != null ? ref1 : (eventType === "enter" ? this.findArguments(options.node) : this.findVariables(options.node));
      }
      if (eventType === "after") {
        functionCalls = (ref2 = options.functionCalls) != null ? ref2 : this.findFunctionCalls(options.node);
      }
      locationObj = "{ first_line: " + loc.start.line + ",";
      locationObj += " first_column: " + (loc.start.column + 1) + ",";
      locationObj += " last_line: " + loc.end.line + ",";
      locationObj += " last_column: " + (loc.end.column + 1) + " }";
      extra = (function() {
        switch (eventType) {
          case "before":
          case "after":
            if (this.options.trackVariables) {
              funcDef = this.isFunctionDef(options.node) ? ", functionDef: true" : "";
              return ", vars: [" + ((function() {
                var j, len, results;
                results = [];
                for (j = 0, len = vars.length; j < len; j++) {
                  name = vars[j];
                  results.push("{name: '" + name + "', value: " + (this.soakify(name)) + " " + funcDef + "}");
                }
                return results;
              }).call(this)) + "]";
            } else {
              return "";
            }
            break;
          case "enter":
            if (this.options.trackVariables) {
              return ", vars: [" + ((function() {
                var j, len, results;
                results = [];
                for (j = 0, len = vars.length; j < len; j++) {
                  name = vars[j];
                  results.push("{name: '" + name + "', value: " + name + "}");
                }
                return results;
              })()) + "]";
            } else {
              return "";
            }
            break;
          case "leave":
            return ", returnOrThrow: " + options.returnOrThrowVar;
        }
      }).call(this);
      if (eventType === "after") {
        if (this.options.includeArgsStrings) {
          extra += ", functionCalls: [" + ((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = functionCalls.length; j < len; j++) {
              f = functionCalls[j];
              results.push("{name: '" + f.name + "', value: " + f.tempVar + ", argsString: '" + (this.quoteString(f.argsString)) + "'}");
            }
            return results;
          }).call(this)) + "]";
        } else {
          extra += ", functionCalls: [" + ((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = functionCalls.length; j < len; j++) {
              f = functionCalls[j];
              results.push("{name: '" + f.name + "', value: " + f.tempVar + "}");
            }
            return results;
          })()) + "]";
        }
      }
      eventObj = "{ location: " + locationObj + ", type: '" + eventType + "'" + extra + " }";
      instrumentedNode = acorn.parse(this.options.traceFunc + "(" + eventObj + ");").body[0];
      instrumentedNode.pencilTracerInstrumented = true;
      instrumentedNode.expression.pencilTracerInstrumented = true;
      return instrumentedNode;
    };

    JavaScriptInstrumenter.prototype.createInstrumentedExpr = function(originalExpr, tempVar) {
      var sequenceExpr;
      if (tempVar == null) {
        tempVar = null;
      }
      if (tempVar === null) {
        tempVar = this.temporaryVariable("temp", true);
      }
      sequenceExpr = {
        type: "SequenceExpression",
        expressions: []
      };
      sequenceExpr.expressions.push(this.createInstrumentedNode("before", {
        node: originalExpr
      }).expression);
      sequenceExpr.expressions.push(this.createAssignNode(tempVar, originalExpr));
      sequenceExpr.expressions.push(this.createInstrumentedNode("after", {
        node: originalExpr
      }).expression);
      sequenceExpr.expressions.push({
        type: "Identifier",
        name: tempVar
      });
      return sequenceExpr;
    };

    JavaScriptInstrumenter.prototype.createAssignNode = function(varName, expr, asStatement) {
      var node;
      if (asStatement == null) {
        asStatement = false;
      }
      node = acorn.parse(varName + " = 0;").body[0];
      node.expression.right = expr;
      node.expression.left.pencilTracerGenerated = true;
      node.expression.loc = expr.loc;
      if (asStatement) {
        return node;
      } else {
        return node.expression;
      }
    };

    JavaScriptInstrumenter.prototype.createReturnNode = function(varName) {
      return acorn.parse("return " + varName + ";", {
        allowReturnOutsideFunction: true
      }).body[0];
    };

    JavaScriptInstrumenter.prototype.createUndefinedNode = function() {
      return acorn.parse("void 0").body[0].expression;
    };

    JavaScriptInstrumenter.prototype.findVariables = function(node, parent, vars) {
      var child, curNode, foundEndOfMemberExpression, ident, j, key, len, name, parts, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      if (parent == null) {
        parent = null;
      }
      if (vars == null) {
        vars = [];
      }
      if (node.pencilTracerGenerated) {
        return [];
      }
      foundEndOfMemberExpression = false;
      if ((ref = node.type) === "Identifier" || ref === "ThisExpression") {
        name = node.type === "ThisExpression" ? "this" : node.name;
        if (vars.indexOf(name) === -1) {
          vars.push(name);
        }
      } else if (node.type === "MemberExpression" && !node.computed) {
        curNode = node;
        parts = [];
        while (curNode.type === "MemberExpression" && !curNode.computed) {
          parts.unshift(curNode.property.name);
          curNode = curNode.object;
        }
        if ((ref1 = curNode.type) === "Identifier" || ref1 === "ThisExpression") {
          foundEndOfMemberExpression = true;
          ident = curNode.type === "ThisExpression" ? "this" : curNode.name;
          parts.unshift(ident);
          if (((ref2 = parent != null ? parent.type : void 0) === "CallExpression" || ref2 === "NewExpression") && parent.callee === node) {
            parts.pop();
          }
          name = parts.join(".");
          if (vars.indexOf(name) === -1) {
            vars.push(name);
          }
        }
      }
      if (!foundEndOfMemberExpression) {
        for (key in node) {
          if (node.type === "Property" && key === "key") {
            continue;
          }
          if (((ref3 = node.type) === "FunctionExpression" || ref3 === "FunctionDeclaration") && key === "params") {
            continue;
          }
          if (node.type === "MemberExpression" && key === "property" && !node.computed) {
            continue;
          }
          if (node.type === "MemberExpression" && key === "object" && ((ref4 = node[key].type) === "Identifier" || ref4 === "ThisExpression") && !node.computed) {
            continue;
          }
          if (((ref5 = node.type) === "CallExpression" || ref5 === "NewExpression") && key === "callee" && ((ref6 = node[key].type) === "ThisExpression" || ref6 === "Identifier")) {
            continue;
          }
          if (isArray(node[key])) {
            ref7 = node[key];
            for (j = 0, len = ref7.length; j < len; j++) {
              child = ref7[j];
              if (ref8 = child.type, indexOf.call(FIND_VARIABLES_IN, ref8) >= 0) {
                this.findVariables(child, node, vars);
              }
            }
          } else if (node[key] && typeof node[key].type === "string") {
            if (ref9 = node[key].type, indexOf.call(FIND_VARIABLES_IN, ref9) >= 0) {
              this.findVariables(node[key], node, vars);
            }
          }
        }
      }
      return vars;
    };

    JavaScriptInstrumenter.prototype.findArguments = function(funcNode) {
      var j, len, param, ref, results;
      ref = funcNode.params;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        results.push(param.name);
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.substringByLocation = function(loc) {
      var j, lineNum, ref, ref1, result;
      result = "";
      for (lineNum = j = ref = loc.start.line, ref1 = loc.end.line; ref <= ref1 ? j <= ref1 : j >= ref1; lineNum = ref <= ref1 ? ++j : --j) {
        result += lineNum === loc.start.line && lineNum === loc.end.line ? this.lines[lineNum].slice(loc.start.column, loc.end.column) : lineNum === loc.start.line ? this.lines[lineNum].slice(loc.start.column) : lineNum === loc.end.line ? this.lines[lineNum].slice(0, loc.end.column) : this.lines[lineNum];
      }
      return result;
    };

    JavaScriptInstrumenter.prototype.argsToString = function(argNodes) {
      var arg;
      return ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = argNodes.length; j < len; j++) {
          arg = argNodes[j];
          results.push(this.substringByLocation(arg.loc));
        }
        return results;
      }).call(this)).join(", ");
    };

    JavaScriptInstrumenter.prototype.findFunctionCalls = function(node, funcs) {
      var child, j, key, len, name, ref, ref1, ref2;
      if (funcs == null) {
        funcs = [];
      }
      if (node.pencilTracerReturnVar) {
        name = node.callee.type === "ThisExpression" ? "this" : node.callee.type === "Identifier" ? node.callee.name : node.callee.type === "MemberExpression" && !node.callee.computed ? node.callee.property.name : "<anonymous>";
        funcs.push({
          name: name,
          tempVar: node.pencilTracerReturnVar,
          argsString: this.argsToString(node["arguments"])
        });
      }
      for (key in node) {
        if (isArray(node[key])) {
          ref = node[key];
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            if (ref1 = child.type, indexOf.call(FIND_VARIABLES_IN, ref1) >= 0) {
              this.findFunctionCalls(child, funcs);
            }
          }
        } else if (node[key] && typeof node[key].type === "string") {
          if (ref2 = node[key].type, indexOf.call(FIND_VARIABLES_IN, ref2) >= 0) {
            this.findFunctionCalls(node[key], funcs);
          }
        }
      }
      return funcs;
    };

    JavaScriptInstrumenter.prototype.shouldInstrumentWithBlock = function(node, parent) {
      var ref;
      return ((ref = node.type) === "EmptyStatement" || ref === "ExpressionStatement" || ref === "DebuggerStatement" || ref === "VariableDeclaration" || ref === "FunctionDeclaration") && !(parent.type === "ForStatement" && parent.init === node) && !(parent.type === "ForInStatement" && parent.left === node) && !(parent.type === "ForInStatement" && parent.body === node);
    };

    JavaScriptInstrumenter.prototype.shouldInstrumentExpr = function(node, parent) {
      return (parent.type === "IfStatement" && parent.test === node) || (parent.type === "WithStatement" && parent.object === node) || (parent.type === "SwitchStatement" && parent.discriminant === node) || (parent.type === "WhileStatement" && parent.test === node) || (parent.type === "DoWhileStatement" && parent.test === node) || (parent.type === "ForStatement" && parent.test === node) || (parent.type === "ForStatement" && parent.update === node) || (parent.type === "ForStatement" && parent.init === node && node.type !== "VariableDeclaration") || (parent.type === "ForInStatement" && parent.right === node) || (parent.type === "SwitchCase" && parent.test === node) || (parent.type === "ThrowStatement");
    };

    JavaScriptInstrumenter.prototype.mapChildren = function(node, func) {
      var child, i, key, results;
      results = [];
      for (key in node) {
        if (isArray(node[key])) {
          results.push((function() {
            var j, len, ref, results1;
            ref = node[key];
            results1 = [];
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              child = ref[i];
              results1.push(node[key][i] = func(child));
            }
            return results1;
          })());
        } else if (node[key] && node[key].type) {
          results.push(node[key] = func(node[key]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.instrumentTree = function(node, parent, returnOrThrowVar) {
      var ref, ref1;
      if (parent == null) {
        parent = null;
      }
      if ((ref = node.type) === "FunctionDeclaration" || ref === "FunctionExpression") {
        returnOrThrowVar = this.temporaryVariable("returnOrThrow");
      }
      if ((ref1 = node.type) === "CallExpression" || ref1 === "NewExpression") {
        node.pencilTracerReturnVar = this.temporaryVariable("returnVar", true);
      }
      if (node.type === "ForStatement" && !node.test && !node.update) {
        node.test = {
          type: "Literal",
          value: true,
          loc: node.loc
        };
      }
      return this.mapChildren(node, (function(_this) {
        return function(child) {
          var newBlock, ref2, ref3, ref4, tryStatement, varDecl;
          _this.instrumentTree(child, node, returnOrThrowVar);
          if (_this.shouldInstrumentWithBlock(child, node)) {
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: child
                }), child, _this.createInstrumentedNode("after", {
                  node: child
                })
              ]
            };
          } else if (_this.shouldInstrumentExpr(child, node)) {
            if (child.pencilTracerReturnVar) {
              return _this.createInstrumentedExpr(child, child.pencilTracerReturnVar);
            } else {
              return _this.createInstrumentedExpr(child);
            }
          } else if (child.pencilTracerReturnVar) {
            return _this.createAssignNode(child.pencilTracerReturnVar, child);
          } else if (child.type === "ForStatement" && ((ref2 = child.init) != null ? ref2.type : void 0) === "VariableDeclaration") {
            varDecl = child.init;
            child.init = null;
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: varDecl
                }), varDecl, _this.createInstrumentedNode("after", {
                  node: varDecl
                }), child
              ]
            };
          } else if (node.type === "ForInStatement" && child === node.body) {
            if (child.type !== "BlockStatement") {
              child = {
                type: "BlockStatement",
                body: [
                  _this.createInstrumentedNode("before", {
                    node: child
                  }), child, _this.createInstrumentedNode("after", {
                    node: child
                  })
                ]
              };
            }
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: node.left
                }), _this.createInstrumentedNode("after", {
                  node: node.left
                }), child
              ]
            };
          } else if (child.type === "ReturnStatement") {
            if (child.argument === null) {
              child.argument = _this.createUndefinedNode();
            }
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: child
                }), _this.createAssignNode(returnOrThrowVar + ".value", child.argument, true), _this.createInstrumentedNode("after", {
                  node: child
                }), _this.createReturnNode(returnOrThrowVar + ".value")
              ]
            };
          } else if ((ref3 = child.type) === "BreakStatement" || ref3 === "ContinueStatement") {
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: child,
                  vars: []
                }), _this.createInstrumentedNode("after", {
                  node: child,
                  vars: []
                }), child
              ]
            };
          } else if (((ref4 = node.type) === "FunctionDeclaration" || ref4 === "FunctionExpression") && node.body === child) {
            newBlock = acorn.parse("{\n  var " + returnOrThrowVar + " = { type: 'return', value: void 0 };\n  try {}\n  catch (" + _this.caughtErrorVar + ") {\n    " + returnOrThrowVar + ".type = 'throw';\n    " + returnOrThrowVar + ".value = " + _this.caughtErrorVar + ";\n    throw " + _this.caughtErrorVar + ";\n  } finally {}\n}").body[0];
            tryStatement = newBlock.body[1];
            tryStatement.block = child;
            newBlock.body.unshift(_this.createInstrumentedNode("enter", {
              node: node
            }));
            tryStatement.finalizer.body.unshift(_this.createInstrumentedNode("leave", {
              node: node,
              returnOrThrowVar: returnOrThrowVar
            }));
            return newBlock;
          } else {
            return child;
          }
        };
      })(this));
    };

    JavaScriptInstrumenter.prototype.instrument = function(code) {
      var ast, name, result, tempVarsDeclaration;
      this.lines = code.match(/^.*((\r\n|\n|\r)|$)/gm);
      this.lines.unshift(null);
      this.undeclaredVars = [];
      this.referencedVars = [];
      ast = acorn.parse(code, {
        locations: true,
        onToken: (function(_this) {
          return function(token) {
            if (token.type.label === "name" && _this.referencedVars.indexOf(token.value) === -1) {
              return _this.referencedVars.push(token.value);
            }
          };
        })(this)
      });
      this.caughtErrorVar = this.temporaryVariable("err");
      this.instrumentTree(ast);
      if (this.undeclaredVars.length > 0) {
        tempVarsDeclaration = {
          type: "VariableDeclaration",
          kind: "var",
          declarations: (function() {
            var j, len, ref, results;
            ref = this.undeclaredVars;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              name = ref[j];
              results.push({
                type: "VariableDeclarator",
                id: {
                  type: "Identifier",
                  name: name
                },
                init: null
              });
            }
            return results;
          }).call(this)
        };
        ast.body.unshift(tempVarsDeclaration);
      }
      if (this.options.ast) {
        return ast;
      }
      if (this.options.sourceMap) {
        result = escodegen.generate(ast, {
          sourceMap: "untitled.js",
          sourceMapWithCode: true
        });
        result.map = result.map.toString();
        return result;
      } else {
        return escodegen.generate(ast);
      }
    };

    return JavaScriptInstrumenter;

  })();

  exports.instrumentJs = function(code, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new JavaScriptInstrumenter(options);
    return instrumenter.instrument(code);
  };

}).call(this);
