// Generated by CoffeeScript 1.9.3
(function() {
  var JavaScriptInstrumenter, acorn, escodegen, isArray,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  acorn = require("acorn");

  escodegen = require("escodegen");

  isArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  JavaScriptInstrumenter = (function() {
    function JavaScriptInstrumenter(options1) {
      var base1;
      this.options = options1;
      if ((base1 = this.options).traceFunc == null) {
        base1.traceFunc = "pencilTrace";
      }
    }

    JavaScriptInstrumenter.prototype.temporaryVariable = function(base) {
      var curName, index, name;
      name = "_penciltracer_" + base;
      index = 0;
      while (true) {
        curName = name + index;
        if (indexOf.call(this.referencedVars, curName) < 0) {
          this.referencedVars.push(curName);
          return curName;
        }
        index++;
      }
    };

    JavaScriptInstrumenter.prototype.createInstrumentedNode = function(eventType, options) {
      var eventObj, extra, f, functionCalls, instrumentedNode, loc, locationObj, name, ref, ref1, ref2, soakify, vars;
      if (options == null) {
        options = {};
      }
      loc = (ref = options.loc) != null ? ref : options.node.loc;
      if (eventType !== "leave") {
        vars = (ref1 = options.vars) != null ? ref1 : (eventType === "enter" ? this.findArguments(options.node) : this.findVariables(options.node));
      }
      if (eventType === "after") {
        functionCalls = (ref2 = options.functionCalls) != null ? ref2 : this.findFunctionCalls(options.node);
      }
      locationObj = "{ first_line: " + loc.start.line + ",";
      locationObj += " first_column: " + (loc.start.column + 1) + ",";
      locationObj += " last_line: " + loc.end.line + ",";
      locationObj += " last_column: " + (loc.end.column + 1) + " }";
      soakify = function(name) {
        if (name.indexOf(".") === -1) {
          return "(typeof " + name + " === 'undefined' ? void 0 : " + name + ")";
        } else {
          throw "todo";
        }
      };
      extra = (function() {
        switch (eventType) {
          case "before":
          case "after":
            return "vars: [" + ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = vars.length; j < len; j++) {
                name = vars[j];
                results.push("{name: '" + name + "', value: " + (soakify(name)) + "}");
              }
              return results;
            })()) + "]";
          case "enter":
            return "vars: [" + ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = vars.length; j < len; j++) {
                name = vars[j];
                results.push("{name: '" + name + "', value: " + name + "}");
              }
              return results;
            })()) + "]";
          case "leave":
            return "returnOrThrow: " + options.returnOrThrowVar;
        }
      })();
      if (eventType === "after") {
        extra += ", functionCalls: [" + ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = functionCalls.length; j < len; j++) {
            f = functionCalls[j];
            results.push("{name: '" + f.name + "', value: " + f.tempVar + "}");
          }
          return results;
        })()) + "]";
      }
      eventObj = "{location: " + locationObj + ", type: '" + eventType + "', " + extra + "}";
      instrumentedNode = acorn.parse(this.options.traceFunc + "(" + eventObj + ");").body[0];
      instrumentedNode.pencilTracerInstrumented = true;
      instrumentedNode.expression.pencilTracerInstrumented = true;
      return instrumentedNode;
    };

    JavaScriptInstrumenter.prototype.createInstrumentedExpr = function(originalExpr) {
      var sequenceExpr, tempVar;
      tempVar = this.temporaryVariable("temp");
      sequenceExpr = {
        type: "SequenceExpression",
        expressions: []
      };
      sequenceExpr.expressions.push(this.createInstrumentedNode("before", {
        node: originalExpr
      }).expression);
      sequenceExpr.expressions.push(this.createAssignNode(tempVar, originalExpr));
      sequenceExpr.expressions.push(this.createInstrumentedNode("after", {
        node: originalExpr
      }).expression);
      sequenceExpr.expressions.push({
        type: "Identifier",
        name: tempVar
      });
      return sequenceExpr;
    };

    JavaScriptInstrumenter.prototype.createAssignNode = function(varName, expr) {
      return {
        type: "AssignmentExpression",
        operator: "=",
        left: {
          type: "Identifier",
          name: varName
        },
        right: expr
      };
    };

    JavaScriptInstrumenter.prototype.findVariables = function(node, vars) {
      var child, j, key, len, ref, ref1, ref2;
      if (vars == null) {
        vars = [];
      }
      if (node.type === "Identifier") {
        if (vars.indexOf(node.name) === -1) {
          vars.push(node.name);
        }
      }
      for (key in node) {
        if (node.type === "Property" && key === "key") {
          continue;
        }
        if (((ref = node.type) === "FunctionExpression" || ref === "FunctionDeclaration") && key === "params") {
          continue;
        }
        if (isArray(node[key])) {
          ref1 = node[key];
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            this.findVariables(child, vars);
          }
        } else if (node[key] && typeof node[key].type === "string" && (ref2 = node[key].type, indexOf.call(STATEMENTS, ref2) < 0)) {
          this.findVariables(node[key], vars);
        }
      }
      return vars;
    };

    JavaScriptInstrumenter.prototype.findArguments = function(funcNode) {
      var j, len, param, ref, results;
      ref = funcNode.params;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        results.push(param.name);
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.findFunctionCalls = function(node, parent, grandparent, vars) {
      if (parent == null) {
        parent = null;
      }
      if (grandparent == null) {
        grandparent = null;
      }
      if (vars == null) {
        vars = [];
      }
      return [];
    };

    JavaScriptInstrumenter.prototype.mapChildren = function(node, func) {
      var child, i, key, results;
      results = [];
      for (key in node) {
        if (isArray(node[key])) {
          results.push((function() {
            var j, len, ref, results1;
            ref = node[key];
            results1 = [];
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              child = ref[i];
              results1.push(node[key][i] = func(child));
            }
            return results1;
          })());
        } else {
          results.push(node[key] = func(node[key]));
        }
      }
      return results;
    };

    JavaScriptInstrumenter.prototype.instrumentTree = function(node, parent, returnOrThrowVar) {
      if (parent == null) {
        parent = null;
      }
      return this.mapChildren(node, (function(_this) {
        return function(child) {
          var ref;
          if ((ref = child.type) === "EmptyStatement" || ref === "ExpressionStatement" || ref === "DebuggerStatement" || ref === "FunctionDeclaration") {
            return {
              type: "BlockStatement",
              body: [
                _this.createInstrumentedNode("before", {
                  node: child
                }), child, _this.createInstrumentedNode("after", {
                  node: child
                })
              ]
            };
          } else {
            return child;
          }
        };
      })(this));
    };

    JavaScriptInstrumenter.prototype.instrument = function(filename, code) {
      var ast;
      this.referencedVars = [];
      ast = acorn.parse(code, {
        locations: true,
        onToken: (function(_this) {
          return function(token) {
            if (token.type.label === "name" && _this.referencedVars.indexOf(token.value) === -1) {
              return _this.referencedVars.push(token.value);
            }
          };
        })(this)
      });
      this.caughtErrorVar = this.temporaryVariable("err");
      this.instrumentTree(ast);
      if (this.options.ast) {
        return ast;
      }
      return escodegen.generate(ast);
    };

    return JavaScriptInstrumenter;

  })();

  exports.instrumentJs = function(filename, code, options) {
    var instrumenter;
    if (options == null) {
      options = {};
    }
    instrumenter = new JavaScriptInstrumenter(options);
    return instrumenter.instrument(filename, code);
  };

}).call(this);
